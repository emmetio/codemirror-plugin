{"version":3,"file":"emmet-codemirror-plugin.js","sources":["../node_modules/@emmetio/extract-abbreviation/dist/extract-abbreviation.es.js","../node_modules/@emmetio/output-profile/dist/output-profile.es.js","../node_modules/@emmetio/snippets-registry/dist/snippets-registry.es.js","../node_modules/@emmetio/node/dist/node.es.js","../node_modules/@emmetio/stream-reader/dist/stream-reader.es.js","../node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.es.js","../node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../node_modules/@emmetio/html-snippets-resolver/dist/html-snippets-resolver.es.js","../node_modules/@emmetio/implicit-tag/dist/implicit-tag.es.js","../node_modules/@emmetio/html-transform/dist/html-transform.es.js","../node_modules/@emmetio/variable-resolver/dist/variable-resolver.es.js","../node_modules/@emmetio/field-parser/dist/field-parser.es.js","../node_modules/@emmetio/output-renderer/dist/output-renderer.es.js","../node_modules/@emmetio/markup-formatters/dist/markup-formatters.es.js","../node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js","../node_modules/@emmetio/stylesheet-formatters/dist/stylesheet-formatters.es.js","../node_modules/@emmetio/snippets/dist/snippets.es.js","../node_modules/@emmetio/lorem/dist/lorem.es.js","../node_modules/@emmetio/expand-abbreviation/dist/expand.es.js","../lib/detect-syntax.js","../lib/stream-reader.js","../lib/utils.js","../lib/expand-abbreviation.js","../lib/abbreviation-marker.js","../lib/commands/wrap-with-abbreviation.js","../lib/autocomplete.js","../node_modules/@emmetio/html-matcher/dist/html-matcher.es.js","../lib/model/syntax-model.js","../lib/model/html.js","../lib/model/index.js","../lib/match-tag.js","../lib/rename-tag.js","../extension.js","../lib/commands/expand-abbreviation.js","../lib/commands/formatted-line-break.js","../browser.js"],"sourcesContent":["/**\n * Minimalistic backwards stream reader\n */\nclass StreamReader {\n\tconstructor(string) {\n\t\tthis.string = string;\n\t\tthis.pos = this.string.length;\n\t}\n\n\tsol() {\n\t\treturn this.pos === 0;\n\t}\n\n\tpeek(offset) {\n\t\treturn this.string.charCodeAt(this.pos - 1 + (offset || 0));\n\t}\n\n\tprev() {\n\t\tif (!this.sol()) {\n\t\t\treturn this.string.charCodeAt(--this.pos);\n\t\t}\n\t}\n\n\teat(match) {\n\t\tconst ok = typeof match === 'function'\n\t\t\t? match(this.peek())\n\t\t\t: match === this.peek();\n\n\t\tif (ok) {\n\t\t\tthis.pos--;\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (this.eat(match)) {}\n\t\treturn this.pos < start;\n\t}\n}\n\n/**\n * Quotes-related utilities\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\nconst ESCAPE       = 92; // \\\n\n/**\n * Check if given character code is a quote\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isQuote(c) {\n\treturn c === SINGLE_QUOTE || c === DOUBLE_QUOTE;\n}\n\n/**\n * Consumes quoted value, if possible\n * @param  {StreamReader} stream\n * @return {Boolean}      Returns `true` is value was consumed\n */\nfunction eatQuoted(stream) {\n\tconst start = stream.pos;\n\tconst quote = stream.prev();\n\n\tif (isQuote(quote)) {\n\t\twhile (!stream.sol()) {\n\t\t\tif (stream.prev() === quote && stream.peek() !== ESCAPE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\nconst TAB         = 9;\nconst SPACE       = 32;\nconst DASH        = 45; // -\nconst SLASH       = 47; // /\nconst COLON       = 58; // :\nconst EQUALS      = 61; // =\nconst ANGLE_LEFT  = 60; // <\nconst ANGLE_RIGHT = 62; // >\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nvar isAtHTMLTag = function (stream) {\n\tconst start = stream.pos;\n\n\tif (!stream.eat(ANGLE_RIGHT)) {\n\t\treturn false;\n\t}\n\n\tlet ok = false;\n\tstream.eat(SLASH); // possibly self-closed element\n\n\twhile (!stream.sol()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (eatIdent(stream)) {\n\t\t\t// ate identifier: could be a tag name, boolean attribute or unquoted\n\t\t\t// attribute value\n\t\t\tif (stream.eat(SLASH)) {\n\t\t\t\t// either closing tag or invalid tag\n\t\t\t\tok = stream.eat(ANGLE_LEFT);\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(ANGLE_LEFT)) {\n\t\t\t\t// opening tag\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(isWhiteSpace)) {\n\t\t\t\t// boolean attribute\n\t\t\t\tcontinue;\n\t\t\t} else if (stream.eat(EQUALS)) {\n\t\t\t\t// simple unquoted value or invalid attribute\n\t\t\t\tif (eatIdent(stream)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (eatAttributeWithUnquotedValue(stream)) {\n\t\t\t\t// identifier was a part of unquoted value\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// invalid tag\n\t\t\tbreak;\n\t\t}\n\n\t\tif (eatAttribute(stream)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tstream.pos = start;\n\treturn ok;\n};\n\n/**\n * Eats HTML attribute from given string.\n * @param  {StreamReader} state\n * @return {Boolean}       `true` if attribute was consumed.\n */\nfunction eatAttribute(stream) {\n\treturn eatAttributeWithQuotedValue(stream) || eatAttributeWithUnquotedValue(stream);\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithQuotedValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithUnquotedValue(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquotedValue) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * Eats HTML identifier from stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatIdent(stream) {\n\treturn stream.eatWhile(isIdent);\n}\n\n/**\n * Check if given character code belongs to HTML identifier\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isIdent(c) {\n\treturn c === COLON || c === DASH || isAlpha(c) || isNumber(c);\n}\n\n/**\n * Check if given character code is alpha code (letter though A to Z)\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isAlpha(c) {\n\tc &= ~32; // quick hack to convert any char code to uppercase char code\n\treturn c >= 65 && c <= 90; // A-Z\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isNumber(c) {\n\treturn c > 47 && c < 58;\n}\n\n/**\n * Check if given code is a whitespace\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isWhiteSpace(c) {\n\treturn c === SPACE || c === TAB;\n}\n\n/**\n * Check if given code may belong to unquoted attribute value\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isUnquotedValue(c) {\n\treturn c && c !== EQUALS && !isWhiteSpace(c) && !isQuote(c);\n}\n\nconst code = ch => ch.charCodeAt(0);\nconst SQUARE_BRACE_L = code('[');\nconst SQUARE_BRACE_R = code(']');\nconst ROUND_BRACE_L  = code('(');\nconst ROUND_BRACE_R  = code(')');\nconst CURLY_BRACE_L  = code('{');\nconst CURLY_BRACE_R  = code('}');\n\nconst specialChars = new Set('#.*:$-_!@%^+>/'.split('').map(code));\nconst bracePairs = new Map()\n.set(SQUARE_BRACE_L, SQUARE_BRACE_R)\n.set(ROUND_BRACE_L,  ROUND_BRACE_R)\n.set(CURLY_BRACE_L,  CURLY_BRACE_R);\n\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param {String}  line A text line where abbreviation should be expanded\n * @param {Number}  [pos] Caret position in line. If not given, uses end-of-line\n * @param {Boolean} [lookAhead] Allow parser to look ahead of `pos` index for\n * searching of missing abbreviation parts. Most editors automatically inserts\n * closing braces for `[`, `{` and `(`, which will most likely be right after\n * current caret position. So in order to properly expand abbreviation, user\n * must explicitly move caret right after auto-inserted braces. Whith this option\n * enabled, parser will search for closing braces right after `pos`. Default is `true`\n * @return {Object} Object with `abbreviation` and its `location` in given line\n * if abbreviation can be extracted, `null` otherwise\n */\nfunction extractAbbreviation(line, pos, lookAhead) {\n\t// make sure `pos` is within line range\n\tpos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n\n\tif (lookAhead == null || lookAhead === true) {\n\t\tpos = offsetPastAutoClosed(line, pos);\n\t}\n\n\tlet c;\n\tconst stream = new StreamReader(line);\n\tstream.pos = pos;\n\tconst stack = [];\n\n\twhile (!stream.sol()) {\n\t\tc = stream.peek();\n\n\t\tif (isCloseBrace(c)) {\n\t\t\tstack.push(c);\n\t\t} else if (isOpenBrace(c)) {\n\t\t\tif (stack.pop() !== bracePairs.get(c)) {\n\t\t\t\t// unexpected brace\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (has(stack, SQUARE_BRACE_R) || has(stack, CURLY_BRACE_R)) {\n\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\tstream.pos--;\n\t\t\tcontinue;\n\t\t} else if (isAtHTMLTag(stream) || !isAbbreviation(c)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstream.pos--;\n\t}\n\n\tif (!stack.length && stream.pos !== pos) {\n\t\t// found something, remove some invalid symbols from the\n\t\t// beginning and return abbreviation\n\t\tconst abbreviation = line.slice(stream.pos, pos).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\treturn {\n\t\t\tabbreviation,\n\t\t\tlocation: pos - abbreviation.length\n\t\t};\n\t}\n}\n\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * edditor will likely automatically close, e.g. }, ], and quotes\n * @param {String} line\n * @param {Number} pos\n * @return {Number}\n */\nfunction offsetPastAutoClosed(line, pos) {\n\t// closing quote is allowed only as a next character\n\tif (isQuote(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\t// offset pointer until non-autoclosed character is found\n\twhile (isCloseBrace(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n}\n\nfunction has(arr, value) {\n\treturn arr.indexOf(value) !== -1;\n}\n\nfunction isAbbreviation(c) {\n\treturn (c > 64 && c < 91)   // uppercase letter\n\t\t|| (c > 96 && c < 123)  // lowercase letter\n\t\t|| (c > 47 && c < 58)   // number\n\t\t|| specialChars.has(c); // special character\n}\n\nfunction isOpenBrace(c) {\n\treturn c === SQUARE_BRACE_L || c === ROUND_BRACE_L || c === CURLY_BRACE_L;\n}\n\nfunction isCloseBrace(c) {\n\treturn c === SQUARE_BRACE_R || c === ROUND_BRACE_R || c === CURLY_BRACE_R;\n}\n\nexport default extractAbbreviation;\n","var defaultOptions = {\n\t/**\n\t * String for one-level indentation\n\t * @type {String}\n\t */\n\tindent: '\\t',\n\n\t/**\n\t * Tag case: 'lower', 'upper' or '' (keep as-is)\n\t * @type {String}\n\t */\n\ttagCase: '',\n\n\t/**\n\t * Attribute name case: 'lower', 'upper' or '' (keep as-is)\n\t * @type {String}\n\t */\n\tattributeCase: '',\n\n\t/**\n\t * Attribute value quotes: 'single' or 'double'\n\t * @type {String}\n\t */\n\tattributeQuotes: 'double',\n\n\t/**\n\t * Enable output formatting (indentation and line breaks)\n\t * @type {Boolean}\n\t */\n\tformat: true,\n\n\t/**\n\t * A list of tag names that should not get inner indentation\n\t * @type {Set}\n\t */\n\tformatSkip: ['html'],\n\n\t/**\n\t * A list of tag names that should *always* get inner indentation.\n\t * @type {Set}\n\t */\n\tformatForce: ['body'],\n\n\t/**\n\t * How many inline sibling elements should force line break for each tag.\n\t * Set to 0 to output all inline elements without formatting.\n\t * Set to 1 to output all inline elements with formatting (same as block-level).\n\t * @type {Number}\n\t */\n\tinlineBreak: 3,\n\n\t/**\n\t * Produce compact notation of boolean attribues: attributes where name equals value.\n\t * With this option enabled, output `<div contenteditable>` instead of\n\t * `<div contenteditable=\"contenteditable\">`\n\t * @type {Boolean}\n\t */\n\tcompactBooleanAttributes: false,\n\n\t/**\n\t * A set of boolean attributes\n\t * @type {Set}\n\t */\n\tbooleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus',\n\t\t'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n\t\t'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n\t\t'required', 'reversed', 'selected', 'typemustmatch'],\n\n\t/**\n\t * Style of self-closing tags:\n\t * 'html'  – <br>\n\t * 'xml'   – <br/>\n\t * 'xhtml' – <br />\n\t * @type {String}\n\t */\n\tselfClosingStyle: 'html',\n\n\t/**\n\t * A set of inline-level elements\n\t * @type {Set}\n\t */\n\tinlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n\t\t'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n\t\t'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n\t\t's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n\t\t'textarea', 'tt', 'u', 'var']\n};\n\n/**\n * Creates output profile for given options (@see defaults)\n * @param {defaults} options\n */\nclass Profile {\n    constructor(options) {\n        this.options = Object.assign({}, defaultOptions, options);\n        this.quoteChar = this.options.attributeQuotes === 'single' ? '\\'' : '\"';\n    }\n\n\t/**\n\t * Returns value of given option name\n\t * @param {String} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.options[name];\n\t}\n\n    /**\n     * Quote given string according to profile\n     * @param {String} str String to quote\n     * @return {String}\n     */\n    quote(str) {\n        return `${this.quoteChar}${str != null ? str : ''}${this.quoteChar}`;\n    }\n\n    /**\n     * Output given tag name accoding to options\n     * @param {String} name\n     * @return {String}\n     */\n    name(name) {\n        return strcase(name, this.options.tagCase);\n    }\n\n\t/**\n\t * Outputs attribute name accoding to current settings\n\t * @param {String} Attribute name\n\t * @return {String}\n\t */\n    attribute(attr) {\n        return strcase(attr, this.options.attributeCase);\n    }\n\n    /**\n     * Check if given attribute is boolean\n     * @param {Attribute} attr\n     * @return {Boolean}\n     */\n    isBooleanAttribute(attr) {\n        return attr.options.boolean\n\t\t\t|| this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;\n    }\n\n\t/**\n\t * Returns a token for self-closing tag, depending on current options\n\t * @return {String}\n\t */\n\tselfClose() {\n\t\tswitch (this.options.selfClosingStyle) {\n\t\t\tcase 'xhtml': return ' /';\n\t\t\tcase 'xml':   return '/';\n\t\t\tdefault:      return '';\n\t\t}\n\t}\n\n\t/**\n\t * Returns indent for given level\n\t * @param {Number} level Indentation level\n\t * @return {String}\n\t */\n\tindent(level) {\n\t\tlevel = level || 0;\n\t\tlet output = '';\n\t\twhile (level--) {\n\t\t\toutput += this.options.indent;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Check if given tag name belongs to inline-level element\n\t * @param {Node|String} node Parsed node or tag name\n\t * @return {Boolean}\n\t */\n\tisInline(node) {\n        if (typeof node === 'string') {\n            return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;\n        }\n\n        // inline node is a node either with inline-level name or text-only node\n        return node.name != null ? this.isInline(node.name) : node.isTextOnly;\n\t}\n\n\t/**\n\t * Outputs formatted field for given params\n\t * @param {Number} index Field index\n\t * @param {String} [placeholder] Field placeholder, can be empty\n\t * @return {String}\n\t */\n\tfield(index, placeholder) {\n\t\treturn this.options.field(index, placeholder);\n\t}\n}\n\nfunction strcase(string, type) {\n    if (type) {\n        string = type === 'upper' ? string.toUpperCase() : string.toLowerCase();\n    }\n    return string;\n}\n\nexport default Profile;\n","class Snippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass SnippetsStorage {\n    constructor(data) {\n        this._string = new Map();\n        this._regexp = new Map();\n        this._disabled = false;\n\n        this.load(data);\n    }\n\n    get disabled() {\n        return this._disabled;\n    }\n\n    /**\n     * Disables current store. A disabled store always returns `undefined`\n     * on `get()` method\n     */\n    disable() {\n        this._disabled = true;\n    }\n\n    /**\n     * Enables current store.\n     */\n    enable() {\n        this._disabled = false;\n    }\n\n    /**\n     * Registers a new snippet item\n     * @param {String|Regexp} key\n     * @param {String|Function} value\n     */\n    set(key, value) {\n        if (typeof key === 'string') {\n            key.split('|').forEach(k => this._string.set(k, new Snippet(k, value)));\n        } else if (key instanceof RegExp) {\n            this._regexp.set(key, new Snippet(key, value));\n        } else {\n            throw new Error('Unknow snippet key: ' + key);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a snippet matching given key. It first tries to find snippet\n     * exact match in a string key map, then tries to match one with regexp key\n     * @param {String} key\n     * @return {Snippet}\n     */\n    get(key) {\n        if (this.disabled) {\n            return undefined;\n        }\n\n        if (this._string.has(key)) {\n            return this._string.get(key);\n        }\n\n        const keys = Array.from(this._regexp.keys());\n        for (let i = 0, il = keys.length; i < il; i++) {\n            if (keys[i].test(key)) {\n                return this._regexp.get(keys[i]);\n            }\n        }\n    }\n\n    /**\n     * Batch load of snippets data\n     * @param {Object|Map} data\n     */\n    load(data) {\n        this.reset();\n        if (data instanceof Map) {\n            data.forEach((value, key) => this.set(key, value));\n        } else if (data && typeof data === 'object') {\n            Object.keys(data).forEach(key => this.set(key, data[key]));\n        }\n    }\n\n    /**\n     * Clears all stored snippets\n     */\n    reset() {\n        this._string.clear();\n        this._regexp.clear();\n    }\n\n    /**\n     * Returns all available snippets from given store\n     */\n    values() {\n        if (this.disabled) {\n            return [];\n        }\n        \n        const string = Array.from(this._string.values());\n        const regexp = Array.from(this._regexp.values());\n        return string.concat(regexp);\n    }\n}\n\n/**\n * A snippets registry. Contains snippets, separated by store and sorted by\n * priority: a store with higher priority takes precedence when resolving snippet\n * for given key\n */\nclass SnippetsRegistry {\n    /**\n     * Creates snippets registry, filled with given `data`\n     * @param {Object|Array} data Registry snippets. If array is given, adds items\n     * from array in order of precedence, registers global snippets otherwise\n     */\n    constructor(data) {\n        this._registry = [];\n\n        if (Array.isArray(data)) {\n            data.forEach((snippets, level) => this.add(level, snippets));\n        } else if (typeof data === 'object') {\n            this.add(data);\n        }\n    }\n\n    /**\n     * Return store for given level\n     * @param {Number} level\n     * @return {SnippetsStorage}\n     */\n    get(level) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const item = this._registry[i];\n            if (item.level === level) {\n                return item.store;\n            }\n        }\n    }\n\n    /**\n     * Adds new store for given level\n     * @param {Number} [level] Store level (priority). Store with higher level\n     * takes precedence when resolving snippets\n     * @param {Object} [snippets] A snippets data for new store\n     * @return {SnipetsStorage}\n     */\n    add(level, snippets) {\n        if (level != null && typeof level === 'object') {\n            snippets = level;\n            level = 0;\n        }\n\n        const store = new SnippetsStorage(snippets);\n\n        // remove previous store from same level\n        this.remove(level);\n\n        this._registry.push({level, store});\n        this._registry.sort((a, b) => b.level - a.level);\n\n        return store;\n    }\n\n    /**\n     * Remove registry with given level or store\n     * @param {Number|SnippetsStorage} data Either level or snippets store\n     */\n    remove(data) {\n        this._registry = this._registry\n        .filter(item => item.level !== data && item.store !== data);\n    }\n\n    /**\n     * Returns snippet from registry that matches given name\n     * @param {String} name\n     * @return {Snippet}\n     */\n    resolve(name) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const snippet = this._registry[i].store.get(name);\n            if (snippet) {\n                return snippet;\n            }\n        }\n    }\n\n    /**\n     * Returns all available snippets from current registry. Snippets with the\n     * same key are resolved by their storage priority.\n     * @param {Object} options\n     * @param {Object} options.type Return snippets only of given type: 'string'\n     * or 'regexp'. Returns all snippets if not defined\n     * @return {Array}\n     */\n    all(options) {\n        options = options || {};\n        const result = new Map();\n\n        const fillResult = snippet => {\n            const type = snippet.key instanceof RegExp ? 'regexp' : 'string';\n            if ((!options.type || options.type === type) && !result.has(snippet.key)) {\n                result.set(snippet.key, snippet);\n            }\n        };\n\n        this._registry.forEach(item => {\n            item.store.values().forEach(fillResult);\n        });\n\n        return Array.from(result.values());\n    }\n\n    /**\n     * Removes all stores from registry\n     */\n    clear() {\n        this._registry.length = 0;\n    }\n}\n\nexport default SnippetsRegistry;\n","/**\n * Attribute descriptor of parsed abbreviation node\n * @param {String} name Attribute name\n * @param {String} value Attribute value\n * @param {Object} options Additional custom attribute options\n * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)\n * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted\n * only if contains non-null value)\n */\nclass Attribute {\n\tconstructor(name, value, options) {\n\t\tthis.name = name;\n\t\tthis.value = value != null ? value : null;\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Create a copy of current attribute\n\t * @return {Attribute}\n\t */\n\tclone() {\n\t\treturn new Attribute(this.name, this.value, Object.assign({}, this.options));\n\t}\n\n\t/**\n\t * A string representation of current node\n\t */\n\tvalueOf() {\n\t\treturn `${this.name}=\"${this.value}\"`;\n\t}\n}\n\n/**\n * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree\n */\nclass Node {\n\t/**\n\t * Creates a new node\n\t * @param {String} [name] Node name\n\t * @param {Array} [attributes] Array of attributes to add\n\t */\n\tconstructor(name, attributes) {\n\t\t// own properties\n\t\tthis.name = name || null;\n\t\tthis.value = null;\n\t\tthis.repeat = null;\n\t\tthis.selfClosing = false;\n\n\t\tthis.children = [];\n\n\t\t/** @type {Node} Pointer to parent node */\n\t\tthis.parent = null;\n\n\t\t/** @type {Node} Pointer to next sibling */\n\t\tthis.next = null;\n\n\t\t/** @type {Node} Pointer to previous sibling */\n\t\tthis.previous = null;\n\n\t\tthis._attributes = [];\n\n\t\tif (Array.isArray(attributes)) {\n\t\t\tattributes.forEach(attr => this.setAttribute(attr));\n\t\t}\n\t}\n\n\t/**\n\t * Array of current node attributes\n\t * @return {Attribute[]} Array of attributes\n\t */\n\tget attributes() {\n\t\treturn this._attributes;\n\t}\n\n\t/**\n\t * A shorthand to retreive node attributes as map\n\t * @return {Object}\n\t */\n\tget attributesMap() {\n\t\treturn this.attributes.reduce((out, attr) => {\n\t\t\tout[attr.name] = attr.options.boolean ? attr.name : attr.value;\n\t\t\treturn out;\n\t\t}, {});\n\t}\n\n\t/**\n\t * Check if current node is a grouping one, e.g. has no actual representation\n\t * and is used for grouping subsequent nodes only\n\t * @return {Boolean}\n\t */\n\tget isGroup() {\n\t\treturn !this.name && !this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Check if given node is a text-only node, e.g. contains only value\n\t * @return {Boolean}\n\t */\n\tget isTextOnly() {\n\t\treturn !this.name && !!this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Returns first child node\n\t * @return {Node}\n\t */\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\t/**\n\t * Returns last child of current node\n\t * @return {Node}\n\t */\n\tget lastChild() {\n\t\treturn this.children[this.children.length - 1];\n\t}\n\n\t/**\n\t * Return index of current node in its parent child list\n\t * @return {Number} Returns -1 if current node is a root one\n\t */\n\tget childIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Returns next sibling of current node\n\t * @return {Node}\n\t */\n\tget nextSibling() {\n\t\treturn this.next;\n\t}\n\n\t/**\n\t * Returns previous sibling of current node\n\t * @return {Node}\n\t */\n\tget previousSibling() {\n\t\treturn this.previous;\n\t}\n\n\t/**\n\t * Returns array of unique class names in current node\n\t * @return {String[]}\n\t */\n\tget classList() {\n\t\tconst attr = this.getAttribute('class');\n\t\treturn attr && attr.value\n\t\t\t? attr.value.split(/\\s+/g).filter(uniqueClass)\n\t\t\t: [];\n\t}\n\n\t/**\n\t * Convenient alias to create a new node instance\n\t * @param {String} [name] Node name\n\t * @param {Object} [attributes] Attributes hash\n\t * @return {Node}\n\t */\n\tcreate(name, attributes) {\n\t\treturn new Node(name, attributes);\n\t}\n\n\t/**\n\t * Sets given attribute for current node\n\t * @param {String|Object|Attribute} name Attribute name or attribute object\n\t * @param {String} [value] Attribute value\n\t */\n\tsetAttribute(name, value) {\n\t\tconst attr = createAttribute(name, value);\n\t\tconst curAttr = this.getAttribute(name);\n\t\tif (curAttr) {\n\t\t\tthis.replaceAttribute(curAttr, attr);\n\t\t} else {\n\t\t\tthis._attributes.push(attr);\n\t\t}\n\t}\n\n\t/**\n\t * Check if attribute with given name exists in node\n\t * @param  {String} name\n\t * @return {Boolean}\n\t */\n\thasAttribute(name) {\n\t\treturn !!this.getAttribute(name);\n\t}\n\n\t/**\n\t * Returns attribute object by given name\n\t * @param  {String} name\n\t * @return {Attribute}\n\t */\n\tgetAttribute(name) {\n\t\tif (typeof name === 'object') {\n\t\t\tname = name.name;\n\t\t}\n\n\t\tfor (var i = 0; i < this._attributes.length; i++) {\n\t\t\tconst attr = this._attributes[i];\n\t\t\tif (attr.name === name) {\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replaces attribute with new instance\n\t * @param {String|Attribute} curAttribute Current attribute name or instance\n\t * to replace\n\t * @param {String|Object|Attribute} newName New attribute name or attribute object\n\t * @param {String} [newValue] New attribute value\n\t */\n\treplaceAttribute(curAttribute, newName, newValue) {\n\t\tif (typeof curAttribute === 'string') {\n\t\t\tcurAttribute = this.getAttribute(curAttribute);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(curAttribute);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1, createAttribute(newName, newValue));\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute with given name\n\t * @param  {String|Attribute} attr Atrtibute name or instance\n\t */\n\tremoveAttribute(attr) {\n\t\tif (typeof attr === 'string') {\n\t\t\tattr = this.getAttribute(attr);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(attr);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from current node\n\t */\n\tclearAttributes() {\n\t\tthis._attributes.length = 0;\n\t}\n\n\t/**\n\t * Adds given class name to class attribute\n\t * @param {String} token Class name token\n\t */\n\taddClass(token) {\n\t\ttoken = normalize(token);\n\n\t\tif (!this.hasAttribute('class')) {\n\t\t\tthis.setAttribute('class', token);\n\t\t} else if (token && !this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.concat(token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Check if current node contains given class name\n\t * @param {String} token Class name token\n\t * @return {Boolean}\n\t */\n\thasClass(token) {\n\t\treturn this.classList.indexOf(normalize(token)) !== -1;\n\t}\n\n\t/**\n\t * Removes given class name from class attribute\n\t * @param {String} token Class name token\n\t */\n\tremoveClass(token) {\n\t\ttoken = normalize(token);\n\t\tif (this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.filter(name => name !== token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Appends child to current node\n\t * @param {Node} node\n\t */\n\tappendChild(node) {\n\t\tthis.insertAt(node, this.children.length);\n\t}\n\n\t/**\n\t * Inserts given `newNode` before `refNode` child node\n\t * @param {Node} newNode\n\t * @param {Node} refNode\n\t */\n\tinsertBefore(newNode, refNode) {\n\t\tthis.insertAt(newNode, this.children.indexOf(refNode));\n\t}\n\n\t/**\n\t * Insert given `node` at `pos` position of child list\n\t * @param {Node} node\n\t * @param {Number} pos\n\t */\n\tinsertAt(node, pos) {\n\t\tif (pos < 0 || pos > this.children.length) {\n\t\t\tthrow new Error('Unable to insert node: position is out of child list range');\n\t\t}\n\n\t\tconst prev = this.children[pos - 1];\n\t\tconst next = this.children[pos];\n\n\t\tnode.remove();\n\t\tnode.parent = this;\n\t\tthis.children.splice(pos, 0, node);\n\n\t\tif (prev) {\n\t\t\tnode.previous = prev;\n\t\t\tprev.next = node;\n\t\t}\n\n\t\tif (next) {\n\t\t\tnode.next = next;\n\t\t\tnext.previous = node;\n\t\t}\n\t}\n\n\t/**\n\t * Removes given child from current node\n\t * @param {Node} node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tif (node.previous) {\n\t\t\t\tnode.previous.next = node.next;\n\t\t\t}\n\n\t\t\tif (node.next) {\n\t\t\t\tnode.next.previous = node.previous;\n\t\t\t}\n\n\t\t\tnode.parent = node.next = node.previous = null;\n\t\t}\n\t}\n\n\t/**\n\t * Removes current node from its parent\n\t */\n\tremove() {\n\t\tif (this.parent) {\n\t\t\tthis.parent.removeChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a detached copy of current node\n\t * @param {Boolean} deep Clone node contents as well\n\t * @return {Node}\n\t */\n\tclone(deep) {\n\t\tconst clone = new Node(this.name);\n\t\tclone.value = this.value;\n\t\tclone.selfClosing = this.selfClosing;\n\t\tif (this.repeat) {\n\t\t\tclone.repeat = Object.assign({}, this.repeat);\n\t\t}\n\n\t\tthis._attributes.forEach(attr => clone.setAttribute(attr.clone()));\n\n\t\tif (deep) {\n\t\t\tthis.children.forEach(child => clone.appendChild(child.clone(true)));\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Walks on each descendant node and invokes given `fn` function on it.\n\t * The function receives two arguments: the node itself and its depth level\n\t * from current node. If function returns `false`, it stops walking\n\t * @param {Function} fn\n\t */\n\twalk(fn, _level) {\n\t\t_level = _level || 0;\n\t\tlet ctx = this.firstChild;\n\n\t\twhile (ctx) {\n\t\t\t// in case if context node will be detached during `fn` call\n\t\t\tconst next = ctx.next;\n\n\t\t\tif (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tctx = next;\n\t\t}\n\t}\n\n\t/**\n\t * A helper method for transformation chaining: runs given `fn` function on\n\t * current node and returns the same node\n\t */\n\tuse(fn) {\n\t\tconst args = [this];\n\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\targs.push(arguments[i]);\n\t\t}\n\n\t\tfn.apply(null, args);\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst attrs = this.attributes.map(attr => {\n\t\t\tattr = this.getAttribute(attr.name);\n\t\t\tconst opt = attr.options;\n\t\t\tlet out = `${opt && opt.implied ? '!' : ''}${attr.name || ''}`;\n\t\t\tif (opt && opt.boolean) {\n\t\t\t\tout += '.';\n\t\t\t} else if (attr.value != null) {\n\t\t\t\tout += `=\"${attr.value}\"`;\n\t\t\t}\n\t\t\treturn out;\n\t\t});\n\n\t\tlet out = `${this.name || ''}`;\n\t\tif (attrs.length) {\n\t\t\tout += `[${attrs.join(' ')}]`;\n\t\t}\n\n\t\tif (this.value != null) {\n\t\t\tout += `{${this.value}}`;\n\t\t}\n\n\t\tif (this.selfClosing) {\n\t\t\tout += '/';\n\t\t}\n\n\t\tif (this.repeat) {\n\t\t\tout += `*${this.repeat.count ? this.repeat.count : ''}`;\n\t\t\tif (this.repeat.value != null) {\n\t\t\t\tout += `@${this.repeat.value}`;\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t}\n}\n\n/**\n * Attribute factory\n * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor\n * @param  {*} value Attribute value\n * @return {Attribute}\n */\nfunction createAttribute(name, value) {\n\tif (name instanceof Attribute) {\n\t\treturn name;\n\t}\n\n\tif (typeof name === 'string') {\n\t\treturn new Attribute(name, value);\n\t}\n\n\tif (name && typeof name === 'object') {\n\t\treturn new Attribute(name.name, name.value, name.options);\n\t}\n}\n\n/**\n * @param  {String} str\n * @return {String}\n */\nfunction normalize(str) {\n\treturn String(str).trim();\n}\n\nfunction uniqueClass(item, i, arr) {\n\treturn item && arr.indexOf(item) === i;\n}\n\nexport default Node;\n","/**\n * A streaming, character code-based string reader\n */\nclass StreamReader {\n\tconstructor(string, start, end) {\n\t\tif (end == null && typeof string === 'string') {\n\t\t\tend = string.length;\n\t\t}\n\n\t\tthis.string = string;\n\t\tthis.pos = this.start = start || 0;\n\t\tthis.end = end;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn this.pos >= this.end;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\n\tlimit(start, end) {\n\t\treturn new this.constructor(this.string, start, end);\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\treturn this.string.charCodeAt(this.pos);\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (this.pos < this.string.length) {\n\t\t\treturn this.string.charCodeAt(this.pos++);\n\t\t}\n\t}\n\n\t/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\n\teat(match) {\n\t\tconst ch = this.peek();\n\t\tconst ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\t\tif (ok) {\n\t\t\tthis.next();\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\t/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (!this.eof() && this.eat(match)) {}\n\t\treturn this.pos !== start;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tthis.pos -= (n || 1);\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\n\tsubstring(start, end) {\n\t\treturn this.string.slice(start, end);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at char ${this.pos + 1}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n}\n\nexport default StreamReader;\n","/**\n * Methods for consuming quoted values\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\n\nconst defaultOptions = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @param  {Number}  options.escape A character code of quote-escape symbol\n * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed\n * @return {Boolean} `true` if quoted string was consumed. The contents\n *                   of quoted string will be availabe as `stream.current()`\n */\nvar eatQuoted = function(stream, options) {\n\toptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;\n\tconst start = stream.pos;\n\tconst quote = stream.peek();\n\n\tif (stream.eat(isQuote)) {\n\t\twhile (!stream.eof()) {\n\t\t\tswitch (stream.next()) {\n\t\t\t\tcase quote:\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase options.escape:\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then stream wasn’t properly consumed.\n\t\t// Revert stream and decide what to do\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error('Unable to consume quoted string');\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isQuote(code) {\n\treturn code === SINGLE_QUOTE || code === DOUBLE_QUOTE;\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isNumber(code) {\n\treturn code > 47 && code < 58;\n}\n\n/**\n * Check if given character code is alpha code (letter through A to Z)\n * @param  {Number}  code\n * @param  {Number}  [from]\n * @param  {Number}  [to]\n * @return {Boolean}\n */\nfunction isAlpha(code, from, to) {\n\tfrom = from || 65; // A\n\tto   = to   || 90; // Z\n\tcode &= ~32; // quick hack to convert any char code to uppercase char code\n\n\treturn code >= from && code <= to;\n}\n\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumeric(code) {\n\treturn isNumber(code) || isAlpha(code);\n}\n\nfunction isWhiteSpace(code) {\n\treturn code === 32   /* space */\n\t\t|| code === 9    /* tab */\n\t\t|| code === 160; /* non-breaking space */\n}\n\n/**\n * Check if given character code is a space\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isSpace(code) {\n\treturn isWhiteSpace(code)\n\t\t|| code === 10  /* LF */\n\t\t|| code === 13; /* CR */\n}\n\nconst defaultOptions$1 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param  {StreamReader} stream\n * @param  {Number} open      Character code of pair openinig\n * @param  {Number} close     Character code of pair closing\n * @param  {Object} [options]\n * @return {Boolean}       Returns `true` if chacarter pair was successfully\n *                         consumed, it’s content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n\toptions = options ? Object.assign({}, defaultOptions$1, options) : defaultOptions$1;\n\tconst start = stream.pos;\n\n\tif (stream.eat(open)) {\n\t\tlet stack = 1, ch;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatQuoted(stream, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tch = stream.next();\n\t\t\tif (ch === open) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === close) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (ch === options.escape) {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport { eatQuoted, isQuote, isAlpha, isNumber, isAlphaNumeric, isSpace, isWhiteSpace, eatPair };\n","import Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\nimport { eatQuoted, isAlphaNumeric, isNumber, isQuote, isSpace, isWhiteSpace } from '@emmetio/stream-reader-utils';\n\nconst ASTERISK = 42; // *\n\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n * @param  {StringReader} stream\n * @return {Object}\n */\nvar consumeRepeat = function(stream) {\n\tif (stream.eat(ASTERISK)) {\n\t\tstream.start = stream.pos;\n\n\t\t// XXX think about extending repeat syntax with through numbering\n\t\treturn { count: stream.eatWhile(isNumber) ? +stream.current() : null };\n\t}\n};\n\nconst opt = { throws: true };\n\n/**\n * Consumes quoted literal from current stream position and returns it’s inner,\n * unquoted, value\n * @param  {StringReader} stream\n * @return {String} Returns `null` if unable to consume quoted value from current\n * position\n */\nvar consumeQuoted = function(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn stream.current().slice(1, -1);\n\t}\n};\n\nconst TEXT_START = 123; // {\nconst TEXT_END = 125; // }\nconst ESCAPE =  92; // \\ character\n\n/**\n * Consumes text node `{...}` from stream\n * @param  {StreamReader} stream\n * @return {String} Returns consumed text value (without surrounding braces) or\n * `null` if there’s no text at starting position\n */\nfunction consumeText(stream) {\n\t// NB using own implementation instead of `eatPair()` from @emmetio/stream-reader-utils\n\t// to disable quoted value consuming\n\tconst start = stream.pos;\n\n\tif (stream.eat(TEXT_START)) {\n\t\tlet stack = 1, ch;\n\t\tlet result = '';\n\t\tlet offset = stream.pos;\n\n\t\twhile (!stream.eof()) {\n\t\t\tch = stream.next();\n\t\t\tif (ch === TEXT_START) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === TEXT_END) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn result + stream.substring(offset, stream.pos - 1);\n\t\t\t\t}\n\t\t\t} else if (ch === ESCAPE) {\n\t\t\t\tch = stream.next();\n\t\t\t\tif (ch === TEXT_START || ch === TEXT_END) {\n\t\t\t\t\tresult += stream.substring(offset, stream.pos - 2) + String.fromCharCode(ch);\n\t\t\t\t\toffset = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\t\tthrow stream.error(`Unable to find closing ${String.fromCharCode(TEXT_END)} for text start`);\n\t}\n\n\treturn null;\n}\n\nconst EXCL       = 33; // .\nconst DOT$1        = 46; // .\nconst EQUALS     = 61; // =\nconst ATTR_OPEN  = 91; // [\nconst ATTR_CLOSE = 93; // ]\n\nconst reAttributeName = /^\\!?[\\w\\-:\\$@]+\\.?$/;\n\n/**\n * Consumes attributes defined in square braces from given stream.\n * Example:\n * [attr col=3 title=\"Quoted string\" selected. support={react}]\n * @param {StringReader} stream\n * @returns {Array} Array of consumed attributes\n */\nvar consumeAttributes = function(stream) {\n\tif (!stream.eat(ATTR_OPEN)) {\n\t\treturn null;\n\t}\n\n\tconst result = [];\n\tlet token, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (stream.eat(ATTR_CLOSE)) {\n\t\t\treturn result; // End of attribute set\n\t\t} else if ((token = consumeQuoted(stream)) != null) {\n\t\t\t// Consumed quoted value: anonymous attribute\n\t\t\tresult.push({\n\t\t\t\tname: null,\n\t\t\t\tvalue: token\n\t\t\t});\n\t\t} else if (eatUnquoted(stream)) {\n\t\t\t// Consumed next word: could be either attribute name or unquoted default value\n\t\t\ttoken = stream.current();\n\t\t\tif (!reAttributeName.test(token)) {\n\t\t\t\t// anonymous attribute\n\t\t\t\tresult.push({ name: null, value: token });\n\t\t\t} else {\n\t\t\t\t// Looks like a regular attribute\n\t\t\t\tattr = parseAttributeName(token);\n\t\t\t\tresult.push(attr);\n\n\t\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\t\t// Explicitly defined value. Could be a word, a quoted string\n\t\t\t\t\t// or React-like expression\n\t\t\t\t\tif ((token = consumeQuoted(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t} else if ((token = consumeText(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t\tattr.options = {\n\t\t\t\t\t\t\tbefore: '{',\n\t\t\t\t\t\t\tafter: '}'\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (eatUnquoted(stream)) {\n\t\t\t\t\t\tattr.value = stream.current();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow stream.error('Expected attribute name');\n\t\t}\n\t}\n\n\tthrow stream.error('Expected closing \"]\" brace');\n};\n\nfunction parseAttributeName(name) {\n\tconst options = {};\n\n\t// If a first character in attribute name is `!` — it’s an implied\n\t// default attribute\n\tif (name.charCodeAt(0) === EXCL) {\n\t\tname = name.slice(1);\n\t\toptions.implied = true;\n\t}\n\n\t// Check for last character: if it’s a `.`, user wants boolean attribute\n\tif (name.charCodeAt(name.length - 1) === DOT$1) {\n\t\tname = name.slice(0, name.length - 1);\n\t\toptions.boolean = true;\n\t}\n\n\tconst attr = { name };\n\tif (Object.keys(options).length) {\n\t\tattr.options = options;\n\t}\n\n\treturn attr;\n}\n\n/**\n * Eats token that can be an unquoted value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatUnquoted(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquoted)) {\n\t\tstream.start = start;\n\t\treturn true;\n\t}\n}\n\nfunction isUnquoted(code) {\n\treturn !isSpace(code) && !isQuote(code)\n\t\t&& code !== ATTR_OPEN && code !== ATTR_CLOSE && code !== EQUALS;\n}\n\nconst HASH    = 35; // #\nconst DOT     = 46; // .\nconst SLASH   = 47; // /\n\n/**\n * Consumes a single element node from current abbreviation stream\n * @param  {StringReader} stream\n * @return {Node}\n */\nvar consumeElement = function(stream) {\n\t// consume element name, if provided\n\tconst start = stream.pos;\n\tconst node = new Node(eatName(stream));\n\tlet next;\n\n\twhile (!stream.eof()) {\n\t\tif (stream.eat(DOT)) {\n\t\t\tnode.addClass(eatName(stream));\n\t\t} else if (stream.eat(HASH)) {\n\t\t\tnode.setAttribute('id', eatName(stream));\n\t\t} else if (stream.eat(SLASH)) {\n\t\t\t// A self-closing indicator must be at the end of non-grouping node\n\t\t\tif (node.isGroup) {\n\t\t\t\tstream.backUp(1);\n\t\t\t\tthrow stream.error('Unexpected self-closing indicator');\n\t\t\t}\n\t\t\tnode.selfClosing = true;\n\t\t\tif (next = consumeRepeat(stream)) {\n\t\t\t\tnode.repeat = next;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (next = consumeAttributes(stream)) {\n\t\t\tfor (let i = 0, il = next.length; i < il; i++) {\n\t\t\t\tnode.setAttribute(next[i]);\n\t\t\t}\n\t\t} else if ((next = consumeText(stream)) !== null) {\n\t\t\tnode.value = next;\n\t\t} else if (next = consumeRepeat(stream)) {\n\t\t\tnode.repeat = next;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === stream.pos) {\n\t\tthrow stream.error(`Unable to consume abbreviation node, unexpected ${stream.peek()}`);\n\t}\n\n\treturn node;\n};\n\nfunction eatName(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isName);\n\treturn stream.current();\n}\n\nfunction isName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === 45 /* - */\n\t\t|| code === 58 /* : */\n\t\t|| code === 36 /* $ */\n\t\t|| code === 64 /* @ */\n\t\t|| code === 33 /* ! */\n\t\t|| code === 95 /* _ */\n\t\t|| code === 37 /* % */;\n}\n\nconst GROUP_START = 40; // (\nconst GROUP_END   = 41; // )\nconst OP_SIBLING  = 43; // +\nconst OP_CHILD    = 62; // >\nconst OP_CLIMB    = 94; // ^\n\n/**\n * Parses given string into a node tree\n * @param  {String} str Abbreviation to parse\n * @return {Node}\n */\nfunction parse(str) {\n\tconst stream = new StreamReader(str.trim());\n\tconst root = new Node();\n\tlet ctx = root, groupStack = [], ch;\n\n\twhile (!stream.eof()) {\n\t\tch = stream.peek();\n\n\t\tif (ch === GROUP_START) { // start of group\n\t\t\t// The grouping node should be detached to properly handle\n\t\t\t// out-of-bounds `^` operator. Node will be attached right on group end\n\t\t\tconst node = new Node();\n\t\t\tgroupStack.push([node, ctx, stream.pos]);\n\t\t\tctx = node;\n\t\t\tstream.next();\n\t\t\tcontinue;\n\t\t} else if (ch === GROUP_END) { // end of group\n\t\t\tconst lastGroup = groupStack.pop();\n\t\t\tif (!lastGroup) {\n\t\t\t\tthrow stream.error('Unexpected \")\" group end');\n\t\t\t}\n\n\t\t\tconst node = lastGroup[0];\n\t\t\tctx = lastGroup[1];\n\t\t\tstream.next();\n\n\t\t\t// a group can have a repeater\n\t\t\tif (node.repeat = consumeRepeat(stream)) {\n\t\t\t\tctx.appendChild(node);\n\t\t\t} else {\n\t\t\t\t// move all children of group into parent node\n\t\t\t\twhile (node.firstChild) {\n\t\t\t\t\tctx.appendChild(node.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for convenience, groups can be joined with optional `+` operator\n\t\t\tstream.eat(OP_SIBLING);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst node = consumeElement(stream);\n\t\tctx.appendChild(node);\n\n\t\tif (stream.eof()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (stream.peek()) {\n\t\t\tcase OP_SIBLING:\n\t\t\t\tstream.next();\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CHILD:\n\t\t\t\tstream.next();\n\t\t\t\tctx = node;\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CLIMB:\n\t\t\t\t// it’s perfectly valid to have multiple `^` operators\n\t\t\t\twhile (stream.eat(OP_CLIMB)) {\n\t\t\t\t\tctx = ctx.parent || ctx;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (groupStack.length) {\n\t\tstream.pos = groupStack.pop()[2];\n\t\tthrow stream.error('Expected group close');\n\t}\n\n\treturn root;\n}\n\n/**\n * Parses given abbreviation and un-rolls it into a full tree: recursively\n * replaces repeated elements with actual nodes\n * @param  {String} abbr\n * @return {Node}\n */\nvar index = function(abbr) {\n\tconst tree = parse(abbr);\n\ttree.walk(unroll);\n\treturn tree;\n};\n\nfunction unroll(node) {\n\tif (!node.repeat || !node.repeat.count) {\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < node.repeat.count; i++) {\n\t\tconst clone = node.clone(true);\n\t\tclone.repeat.value = i+1;\n\t\tclone.walk(unroll);\n\t\tif (clone.isGroup) {\n\t\t\twhile (clone.children.length > 0) {\n\t\t\t\tclone.firstChild.repeat = clone.repeat;\n\t\t\t\tnode.parent.insertBefore(clone.firstChild, node);\n\t\t\t}\n\t\t} else {\n\t\t\tnode.parent.insertBefore(clone, node);\n\t\t}\n\t}\n\t\n\tnode.parent.removeChild(node);\n}\n\nexport default index;\n","import parse from '@emmetio/abbreviation';\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * resolves it into a parsed abbreviation. Resolved node is then updated or\n * replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attribues and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n *\n * @param  {Node} tree                 Parsed Emmet abbreviation\n * @param  {SnippetsRegistry} registry Registry with all available snippets\n * @return {Node} Updated tree\n */\n\nvar index = function(tree, registry) {\n    tree.walk(node => resolveNode(node, registry));\n    return tree;\n};\n\nfunction resolveNode(node, registry) {\n    const stack = new Set();\n    const resolve = node => {\n        const snippet = registry.resolve(node.name);\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.has(snippet)) {\n            return;\n        }\n\n        // In case if matched snippet is a function, pass control into it\n        if (typeof snippet.value === 'function') {\n            return snippet.value(node, registry, resolve);\n        }\n\n        const tree = parse(snippet.value);\n\n        stack.add(snippet);\n        tree.walk(resolve);\n        stack.delete(snippet);\n\n        // move current node contents into new tree\n        const childTarget = findDeepestNode(tree);\n        merge(childTarget, node);\n\n        while (tree.firstChild) {\n            node.parent.insertBefore(tree.firstChild, node);\n        }\n\n        childTarget.parent.insertBefore(node, childTarget);\n        childTarget.remove();\n    };\n\n    resolve(node);\n}\n\n/**\n * Adds data from first node into second node and returns it\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction merge(from, to) {\n    to.name = from.name;\n\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n\n    if (from.value != null) {\n        to.value = from.value;\n    }\n\n    if (from.repeat) {\n        to.repeat = Object.assign({}, from.repeat);\n    }\n\n    return mergeAttributes(from, to);\n}\n\n/**\n * Transfer attributes from first element to second one and preserve first\n * element’s attributes order\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeAttributes(from, to) {\n    mergeClassNames(from, to);\n\n    // It’s important to preserve attributes order: ones in `from` have higher\n    // pripority than in `to`. Collect attributes in map in order they should\n    // appear in `to`\n    const attrMap = new Map();\n\n    let attrs = from.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        attrMap.set(attrs[i].name, attrs[i].clone());\n    }\n\n    attrs = to.attributes.slice();\n    for (let i = 0, attr, a; i < attrs.length; i++) {\n        attr = attrs[i];\n        if (attrMap.has(attr.name)) {\n            a = attrMap.get(attr.name);\n            a.value = attr.value;\n\n            // If user explicitly wrote attribute in abbreviation, it’s no longer\n            // implied and should be outputted even if value is empty\n            if (a.options.implied) {\n                a.options.implied = false;\n            }\n        } else {\n            attrMap.set(attr.name, attr);\n        }\n\n        to.removeAttribute(attr);\n    }\n\n    const newAttrs = Array.from(attrMap.values());\n    for (let i = 0; i < newAttrs.length; i++) {\n        to.setAttribute(newAttrs[i]);\n    }\n\n    return to;\n}\n\n/**\n * Adds class names from first node to second one\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeClassNames(from, to) {\n    const classNames = from.classList;\n    for (let i = 0; i < classNames.length; i++) {\n        to.addClass(classNames[i]);\n    }\n\n    return to;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\nexport default index;\n","const inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\n\n/**\n * Returns best child node name for given parent node name\n * @param  {String} parentName Name of parent node\n * @return {String}\n */\nfunction resolveImplicitName(parentName) {\n    parentName = (parentName || '').toLowerCase();\n    return elementMap[parentName]\n        || (inlineElements.has(parentName) ? 'span' : 'div');\n}\n\nexport default resolveImplicitName;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\n/**\n * Adds missing tag names for given tree depending on node’s parent name\n */\nvar implicitTags = function(tree) {\n    tree.walk(node => {\n        // resolve only nameless nodes without content\n        if (node.name == null && node.attributes.length) {\n            node.name = resolveImplicitTag(node.parent.name);\n        }\n    });\n    return tree;\n};\n\n/**\n * Locates all occurances of given `token` which are not escaped (e.g. are not\n * preceded with `\\`) given in `str`\n * @param  {String} str\n * @return {Array}  Array of token ranges\n */\nfunction findUnescapedTokens(str, token) {\n    const result = new Set();\n    const tlen = token.length;\n\n    // 1. Find all occurances of tokens\n    let pos = 0;\n    while ((pos = str.indexOf(token, pos)) !== -1) {\n        result.add(pos);\n        pos += tlen;\n    }\n\n    if (result.size) {\n        // 2. Remove ones that escaped\n        let pos = 0;\n        const len = str.length;\n\n        while (pos < len) {\n            if (str[pos++] === '\\\\') {\n                result.delete(pos++);\n            }\n        }\n    }\n\n    return Array.from(result).map(ix => range(ix, tlen));\n}\n\n/**\n * Replaces `ranges`, generated by `range()` function, with given `value` in `str`\n * @param  {String} str    Where to replace ranges\n * @param  {Array} ranges Ranes, created by `range()` function\n * @param  {String|Function} value  Replacement value. If it’s a function, it\n * will take a range value as argument and should return a new string\n * @return {String}\n */\nfunction replaceRanges(str, ranges, value) {\n\t// should walk from the end of array to keep ranges valid after replacement\n\tfor (let i = ranges.length - 1; i >= 0; i--) {\n\t\tconst r = ranges[i];\n\n        let offset = 0;\n        let offsetLength = 0;\n        let descendingOrder = false;\n\n        if (str.substr(r[0] + r[1], 1) === '@'){\n            if (str.substr(r[0] + r[1] + 1, 1) === '-') {\n                descendingOrder = true;\n            } \n            const matches = str.substr(r[0] + r[1] + 1 + Number(descendingOrder)).match(/^(\\d+)/);\n            if (matches) {\n                offsetLength = matches[1].length + 1 + Number(descendingOrder);\n                offset = parseInt(matches[1]) - 1;\n            } else {\n                offsetLength = 2;\n            }\n        }\n\n\t\tstr = str.substring(0, r[0])\n\t\t\t+ (typeof value === 'function' ? value(str.substr(r[0], r[1]), offset, descendingOrder) : value)\n\t\t\t+ str.substring(r[0] + r[1] + offsetLength);\n\t}\n\n\treturn str;\n}\n\nfunction range(start, length) {\n    return [start, length];\n}\n\nconst numberingToken = '$';\n\n/**\n * Numbering of expanded abbreviation: finds all nodes with `$` in value\n * or attributes and replaces its occurances with repeater value\n */\nvar applyNumbering = function(tree) {\n    tree.walk(applyNumbering$1);\n    return tree;\n};\n\n/**\n * Applies numbering for given node: replaces occurances of numbering token\n * in node’s name, content and attributes\n * @param  {Node} node\n * @return {Node}\n */\nfunction applyNumbering$1(node) {\n    const repeater = findRepeater(node);\n\n    if (repeater && repeater.value != null) {\n        // NB replace numbering in nodes with explicit repeater only:\n        // it solves issues with abbreviations like `xsl:if[test=$foo]` where\n        // `$foo` is preferred output\n        const value = repeater.value;\n        const count = repeater.count;\n\n        node.name = replaceNumbering(node.name, value, count);\n        node.value = replaceNumbering(node.value, value, count);\n        node.attributes.forEach(attr => {\n            const copy = node.getAttribute(attr.name).clone();\n            copy.name = replaceNumbering(attr.name, value, count);\n            copy.value = replaceNumbering(attr.value, value, count);\n            node.replaceAttribute(attr.name, copy);\n        });\n    }\n\n    return node;\n}\n\n/**\n * Returns repeater object for given node\n * @param  {Node} node\n * @return {Object}\n */\nfunction findRepeater(node) {\n    while (node) {\n        if (node.repeat) {\n            return node.repeat;\n        }\n\n        node = node.parent;\n    }\n}\n\n/**\n * Replaces numbering in given string\n * @param  {String} str\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumbering(str, value, count) {\n    // replace numbering in strings only: skip explicit wrappers that could\n    // contain unescaped numbering tokens\n    if (typeof str === 'string') {\n        const ranges = getNumberingRanges(str);\n        return replaceNumberingRanges(str, ranges, value, count);\n    }\n\n    return str;\n}\n\n/**\n * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.\n * Multiple adjacent ranges are combined\n * @param  {String} str\n * @return {Array}\n */\nfunction getNumberingRanges(str) {\n    return findUnescapedTokens(str || '', numberingToken)\n    .reduce((out, range$$1) => {\n        // skip ranges that actually belongs to output placeholder or tabstops\n        if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {\n            const lastRange = out[out.length - 1];\n            if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {\n                lastRange[1] += range$$1[1];\n            } else {\n                out.push(range$$1);\n            }\n        }\n\n        return out;\n    }, []);\n}\n\n/**\n * @param  {String} str\n * @param  {Array} ranges\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumberingRanges(str, ranges, value, count) {\n    const replaced = replaceRanges(str, ranges, (token, offset, descendingOrder) => {\n    let _value = descendingOrder ? String(offset + count - value + 1) : String(value + offset);\n        // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003\n        while (_value.length < token.length) {\n            _value = '0' + _value;\n        }\n        return _value;\n    });\n\n    // unescape screened numbering tokens\n    return unescapeString(replaced);\n}\n\n/**\n * Unescapes characters, screened with `\\`, in given string\n * @param  {String} str\n * @return {String}\n */\nfunction unescapeString(str) {\n    let i = 0, result = '';\n    const len = str.length;\n\n    while (i < len) {\n        const ch = str[i++];\n        result += (ch === '\\\\') ? (str[i++] || '') : ch;\n    }\n\n    return result;\n}\n\n/** Placeholder for inserted content */\nconst placeholder = '$#';\n\n/** Placeholder for caret */\nconst caret = '|';\n\nconst reUrl = /^((?:https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\nconst reEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\nconst reProto = /^([a-z]+:)?\\/\\//i;\n\n/**\n * Inserts content into node with implicit repeat count: this node is then\n * duplicated for each content item and content itself is inserted either into\n * deepest child or instead of a special token.\n *\n * This method uses two distinct steps: `prepare()` and `insert()` since most\n * likely these steps will be used separately to properly insert content\n * with unescaped `$` numbering markers.\n *\n * @param {Node} tree Parsed abbreviation\n * @param {String[]} content Array of content items to insert\n * @return {Node}\n */\n/**\n * Finds nodes with implicit repeat and creates `amount` copies of it in tree\n * @param  {Node} tree\n * @param  {Number} amount\n * @return {Node}\n */\nfunction prepare(tree, amount) {\n    amount = amount || 1;\n    tree.walk(node => {\n        if (node.repeat && node.repeat.count === null) {\n            for (let i = 0; i < amount; i++) {\n                const clone = node.clone(true);\n                clone.repeat.implicit = true;\n                clone.repeat.count = amount;\n                clone.repeat.value = i + 1;\n                clone.repeat.index = i;\n                node.parent.insertBefore(clone, node);\n            }\n\n            node.remove();\n        }\n    });\n\n    return tree;\n}\n\n/**\n * Inserts content into implicitly repeated nodes, created by `prepare()` method\n * @param  {Node} tree\n * @param  {String[]} content\n * @return {Node}\n */\nfunction insert(tree, content) {\n    if (Array.isArray(content) && content.length) {\n        let updated = false;\n        tree.walk(node => {\n            if (node.repeat && node.repeat.implicit) {\n                updated = true;\n                insertContent(node, content[node.repeat.index]);\n            }\n        });\n\n        if (!updated) {\n            // no node with implicit repeat was found, insert content as\n            // deepest child\n            setNodeContent(findDeepestNode(tree), content.join('\\n'));\n        }\n    }\n\n    return tree;\n}\n\n/**\n * Inserts `content` into given `node`: either replaces output placeholders\n * or inserts it into deepest child node\n * @param  {Node} node\n * @param  {String} content\n * @return {Node}\n */\nfunction insertContent(node, content) {\n\tlet inserted = insertContentIntoPlaceholder(node, content);\n\tnode.walk(child => inserted |= insertContentIntoPlaceholder(child, content));\n\n\tif (!inserted) {\n\t\t// no placeholders were found in node, insert content into deepest child\n\t\tsetNodeContent(findDeepestNode(node), content);\n\t}\n\n\treturn node;\n}\n\n/**\n * Inserts given `content` into placeholders for given `node`. Placeholders\n * might be available in attribute values and node content\n * @param  {Node} node\n * @param  {String} content\n * @return {Boolean} Returns `true` if placeholders were found and replaced in node\n */\nfunction insertContentIntoPlaceholder(node, content) {\n\tconst state = {replaced: false};\n\n\tnode.value = replacePlaceholder(node.value, content, state);\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.value) {\n\t\t\tnode.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));\n\t\t}\n\t});\n\n\treturn state.replaced;\n}\n\n/**\n * Replaces all placeholder occurances in given `str` with `value`\n * @param  {String} str\n * @param  {String} value\n * @param  {Object} [_state] If provided, set `replaced` property of given\n * object to `true` if placeholder was found and replaced\n * @return {String}\n */\nfunction replacePlaceholder(str, value, _state) {\n\tif (typeof str === 'string') {\n\t\tconst ranges = findUnescapedTokens(str, placeholder);\n\t\tif (ranges.length) {\n\t\t\tif (_state) {\n\t\t\t\t_state.replaced = true;\n\t\t\t}\n\n\t\t\tstr = replaceRanges(str, ranges, value);\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\n/**\n * Updates content of given node\n * @param {Node} node\n * @param {String} content\n */\nfunction setNodeContent(node, content) {\n\t// find caret position and replace it with content, if possible\n\tif (node.value) {\n\t\tconst ranges = findUnescapedTokens(node.value, caret);\n\t\tif (ranges.length) {\n\t\t\tnode.value = replaceRanges(node.value, ranges, content);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (node.name.toLowerCase() === 'a' || node.hasAttribute('href')) {\n\t\t// special case: inserting content into `<a>` tag\n\t\tif (reUrl.test(content)) {\n\t\t\tnode.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);\n\t\t} else if (reEmail.test(content)) {\n\t\t\tnode.setAttribute('href', 'mailto:' + content);\n\t\t}\n\t}\n\n\tnode.value = content;\n}\n\nconst defaultOptions = {\n\telement: '__',\n\tmodifier: '_'\n};\n\nconst reElement  = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-]*)/i;\nconst blockCandidates1 = className => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = className => /^[a-z]/i.test(className);\n\n/**\n * BEM transformer: updates class names written as `-element` and\n * `_modifier` into full class names as described in BEM specs. Also adds missing\n * class names: fir example, if node contains `.block_modifier` class, ensures\n * that element contains `.block` class as well\n */\nvar bem = function(tree, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\ttree.walk(node => expandClassNames(node, options));\n\n\tconst lookup = createBlockLookup(tree);\n\ttree.walk(node => expandShortNotation(node, lookup, options));\n\n\treturn tree;\n};\n\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n * @param  {Node} node\n * @param  {Object} options\n * @return {Set}\n */\nfunction expandClassNames(node, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\t// remove all modifiers and element prefixes from class name to get a base element name\n\t\tconst ix = cl.indexOf('_');\n\t\tif (ix > 0 && !cl.startsWith('-')) {\n\t\t\tout.add(cl.slice(0, ix));\n\t\t    out.add(cl.slice(ix));\n\t\t\treturn out;\n\t\t}\n\n\t\treturn out.add(cl);\n\t}, new Set());\n\n\tif (classNames.size) {\n\t\tnode.setAttribute('class', Array.from(classNames).join(' '));\n\t}\n}\n\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n * @param  {Node} node      Parsed Emmet abbreviation node\n * @param  {Map} lookup     BEM block name lookup\n * @param  {Object} options\n */\nfunction expandShortNotation(node, lookup, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\tlet prefix, m;\n\t\tconst originalClass = cl;\n\n\t\t// parse element definition (could be only one)\n\t\tif (m = cl.match(reElement)) {\n\t\t\tprefix = getBlockName(node, lookup, m[1]) + options.element + m[2];\n\t\t\tout.add(prefix);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\t// parse modifiers definitions (may contain multiple)\n\t\twhile (m = cl.match(reModifier)) {\n\t\t\tif (!prefix) {\n\t\t\t\tprefix = getBlockName(node, lookup, m[1]);\n\t\t\t\tout.add(prefix);\n\t\t\t}\n\n\t\t\tout.add(`${prefix}${options.modifier}${m[2]}`);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\tif (cl === originalClass) {\n\t\t\t// class name wasn’t modified: it’s not a BEM-specific class,\n\t\t\t// add it as-is into output\n\t\t\tout.add(originalClass);\n\t\t}\n\n\t\treturn out;\n\t}, new Set());\n\n\tconst arrClassNames = Array.from(classNames).filter(Boolean);\n\tif (arrClassNames.length) {\n\t\tnode.setAttribute('class', arrClassNames.join(' '));\n\t}\n}\n\n/**\n * Creates block name lookup for each node in given tree, e.g. finds block\n * name explicitly for each node\n * @param  {Node} tree\n * @return {Map}\n */\nfunction createBlockLookup(tree) {\n\tconst lookup = new Map();\n\n\ttree.walk(node => {\n\t\tconst classNames = node.classList;\n\t\tif (classNames.length) {\n\t\t\t// guess best block name from class or use parent’s block name\n\t\t\tlookup.set(node,\n\t\t\t\tfind(classNames, blockCandidates1)\n\t\t\t\t|| find(classNames, blockCandidates2)\n\t\t\t\t|| lookup.get(node.parent)\n\t\t\t);\n\t\t}\n\t});\n\n\treturn lookup;\n}\n\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n * @param  {Node} node\n * @param  {Map} lookup\n * @param  {String} prefix\n * @return {String}\n */\nfunction getBlockName(node, lookup, prefix) {\n\tlet depth = prefix.length > 1 ? prefix.length : 0;\n\n\t// NB don’t walk up to root node, stay at first root child in case of\n\t// too deep prefix\n\twhile (node.parent && node.parent.parent && depth--) {\n\t\tnode = node.parent;\n\t}\n\n\treturn lookup.get(node) || '';\n}\n\nfunction find(arr, filter) {\n\treturn arr.filter(filter)[0];\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nvar jsx = function(tree) {\n\ttree.walk(node => {\n\t\treplace(node, 'class', 'className');\n\t\treplace(node, 'for', 'htmlFor');\n\t});\n\treturn tree;\n};\n\nfunction replace(node, oldName, newName) {\n\tlet attr = node.getAttribute(oldName);\n\tif (attr) {\n\t\tattr.name = newName;\n\t}\n}\n\nconst reSupporterNames = /^xsl:(variable|with\\-param)$/i;\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nvar xsl = function(tree) {\n\ttree.walk(node => {\n\t\tif (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {\n\t\t\tnode.removeAttribute('select');\n\t\t}\n\t});\n\treturn tree;\n};\n\nconst supportedAddons = { bem, jsx, xsl };\n\n/**\n * Runs additional transforms on given tree.\n * These transforms may introduce side-effects and unexpected result\n * so they are not applied by default, authors must specify which addons\n * in `addons` argument as `{addonName: addonOptions}`\n * @param {Node} tree Parsed Emmet abbreviation\n * @param {Object} addons Add-ons to apply and their options\n */\nvar addons = function(tree, addons) {\n    Object.keys(addons || {}).forEach(key => {\n        if (key in supportedAddons) {\n            const addonOpt = typeof addons[key] === 'object' ? addons[key] : null;\n            tree = tree.use(supportedAddons[key], addonOpt);\n        }\n    });\n\n    return tree;\n};\n\n/**\n * Applies basic HTML-specific transformations for given parsed abbreviation:\n * – resolve implied tag names\n * – insert repeated content\n * – resolve node numbering\n */\nvar index = function(tree, content, appliedAddons) {\n    if (typeof content === 'string') {\n        content = [content];\n    } else if (content && typeof content === 'object' && !Array.isArray(content)) {\n        appliedAddons = content;\n        content = null;\n    }\n\n    return tree\n    .use(implicitTags)\n    .use(prepare, Array.isArray(content) ? content.length : null)\n    .use(applyNumbering)\n    .use(insert, content)\n    .use(addons, appliedAddons);\n};\n\nexport default index;\n","/**\n * Replaces all unescaped ${variable} occurances in given parsed abbreviation\n * `tree` with values provided in `variables` hash. Precede `$` with `\\` to\n * escape it and skip replacement\n * @param {Node} tree Parsed abbreviation tree\n * @param {Object} variables Variables values\n * @return {Node}\n */\nfunction replaceVariables(tree, variables) {\n\tvariables = variables || {};\n    tree.walk(node => replaceInNode(node, variables));\n    return tree;\n}\n\nfunction replaceInNode(node, variables) {\n    // Replace variables in attributes.\n    const attrs = node.attributes;\n\n    for (let i = 0, il = attrs.length; i < il; i++) {\n        const attr = attrs[i];\n        if (typeof attr.value === 'string') {\n            node.setAttribute(attr.name, replaceInString(attr.value, variables));\n        }\n    }\n\n    if (node.value != null) {\n        node.value = replaceInString(node.value, variables);\n    }\n\n    return node;\n}\n\n/**\n * Replaces all unescaped `${variable}` occurances in given string with values\n * from `variables` object\n * @param  {String} string\n * @param  {Object} variables\n * @return {String}\n */\nfunction replaceInString(string, variables) {\n    const model = createModel(string);\n    let offset = 0;\n    let output = '';\n\n    for (let i = 0, il = model.variables.length; i < il; i++) {\n        const v = model.variables[i];\n        let value = v.name in variables ? variables[v.name] : v.name;\n        if (typeof value === 'function') {\n            value = value(model.string, v, offset + v.location);\n        }\n\n        output += model.string.slice(offset, v.location) + value;\n        offset = v.location + v.length;\n    }\n\n    return output + model.string.slice(offset);\n}\n\n/**\n * Creates variable model from given string. The model contains a `string` with\n * all escaped variable tokens written without escape symbol and `variables`\n * property with all unescaped variables and their ranges\n * @param  {String} string\n * @return {Object}\n */\nfunction createModel(string) {\n    const reVariable = /\\$\\{([a-z][\\w\\-]*)\\}/ig;\n    const escapeCharCode = 92; // `\\` symbol\n    const variables = [];\n\n    // We have to replace unescaped (e.g. not preceded with `\\`) tokens.\n    // Instead of writing a stream parser, we’ll cut some edges here:\n    // 1. Find all tokens\n    // 2. Walk string char-by-char and resolve only tokens that are not escaped\n    const tokens = new Map();\n    let m;\n    while (m = reVariable.exec(string)) {\n        tokens.set(m.index, m);\n    }\n\n    if (tokens.size) {\n        let start = 0, pos = 0, len = string.length;\n        let output = '';\n        while (pos < len) {\n            if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {\n                // Found escape symbol that escapes variable: we should\n                // omit this symbol in output string and skip variable\n                const token = tokens.get(pos + 1);\n                output += string.slice(start, pos) + token[0];\n                start = pos = token.index + token[0].length;\n                tokens.delete(pos + 1);\n                continue;\n            }\n\n            pos++;\n        }\n\n        string = output + string.slice(start);\n\n        // Not using `.map()` here to reduce memory allocations\n        const validMatches = Array.from(tokens.values());\n        for (let i = 0, il = validMatches.length; i < il; i++) {\n            const token = validMatches[i];\n            variables.push({\n                name: token[1],\n                location: token.index,\n                length: token[0].length\n            });\n        }\n    }\n\n    return {string, variables};\n}\n\nexport default replaceVariables;\n","import StreamReader from '@emmetio/stream-reader';\nimport { isNumber } from '@emmetio/stream-reader-utils';\n\nconst DOLLAR      = 36;  // $\nconst COLON       = 58;  // :\nconst ESCAPE      = 92;  // \\\nconst OPEN_BRACE  = 123; // {\nconst CLOSE_BRACE = 125; // }\n\n/**\n * Finds fields in given string and returns object with field-less string\n * and array of fileds found\n * @param  {String} string\n * @return {Object}\n */\nfunction parse(string) {\n\tconst stream = new StreamReader(string);\n\tconst fields = [];\n\tlet cleanString = '', offset = 0, pos = 0;\n\tlet code, field;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\t\tpos = stream.pos;\n\n\t\tif (code === ESCAPE) {\n\t\t\tstream.next();\n\t\t\tstream.next();\n\t\t} else if (field = consumeField(stream, cleanString.length + pos - offset)) {\n\t\t\tfields.push(field);\n\t\t\tcleanString += stream.string.slice(offset, pos) + field.placeholder;\n\t\t\toffset = stream.pos;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn new FieldString(cleanString + stream.string.slice(offset), fields);\n}\n\n/**\n * Marks given `string` with `fields`: wraps each field range with\n * `${index:placeholder}` (by default) or any other token produced by `token`\n * function, if provided\n * @param  {String} string String to mark\n * @param  {Array} fields Array of field descriptor. A field descriptor is a\n * `{index, location, length}` array. It is important that fields in array\n * must be ordered by their location in string: some fields my refer the same\n * location so they must appear in order that user expects.\n * @param  {Function} [token] Function that generates field token. This function\n * received two arguments: `index` and `placeholder` and should return string\n * @return {String}  String with marked fields\n */\nfunction mark(string, fields, token) {\n\ttoken = token || createToken;\n\n\t// order fields by their location and appearence\n\t// NB field ranges should not overlap! (not supported yet)\n\tconst ordered = fields\n\t.map((field, order) => ({order, field, end: field.location + field.length}))\n\t.sort((a, b) => (a.end - b.end) || (a.order - b.order));\n\n\t// mark ranges in string\n\tlet offset = 0;\n\tconst result = ordered.map(item => {\n\t\tconst placeholder = string.substr(item.field.location, item.field.length);\n\t\tconst prefix = string.slice(offset, item.field.location);\n\t\toffset = item.end;\n\t\treturn prefix + token(item.field.index, placeholder);\n\t});\n\n\treturn result.join('') + string.slice(offset);\n}\n\n/**\n * Creates field token for string\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, could be empty string\n * @return {String}\n */\nfunction createToken(index, placeholder) {\n\treturn placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Consumes field from current stream position: it can be an `$index` or\n * or `${index}` or `${index:placeholder}`\n * @param  {StreamReader} stream\n * @param  {Number}       location Field location in *clean* string\n * @return {Object} Object with `index` and `placeholder` properties if\n * fieald was successfully consumed, `null` otherwise\n */\nfunction consumeField(stream, location) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(DOLLAR)) {\n\t\t// Possible start of field\n\t\tlet index = consumeIndex(stream);\n\t\tlet placeholder = '';\n\n\t\t// consumed $index placeholder\n\t\tif (index != null) {\n\t\t\treturn new Field(index, placeholder, location);\n\t\t}\n\n\t\tif (stream.eat(OPEN_BRACE)) {\n\t\t\tindex = consumeIndex(stream);\n\t\t\tif (index != null) {\n\t\t\t\tif (stream.eat(COLON)) {\n\t\t\t\t\tplaceholder = consumePlaceholder(stream);\n\t\t\t\t}\n\n\t\t\t\tif (stream.eat(CLOSE_BRACE)) {\n\t\t\t\t\treturn new Field(index, placeholder, location);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we reached here then there’s no valid field here, revert\n\t// back to starting position\n\tstream.pos = start;\n}\n\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumePlaceholder(stream) {\n\tlet code;\n\tconst stack = [];\n\tstream.start = stream.pos;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\tif (code === OPEN_BRACE) {\n\t\t\tstack.push(stream.pos);\n\t\t} else if (code === CLOSE_BRACE) {\n\t\t\tif (!stack.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t\tstream.next();\n\t}\n\n\tif (stack.length) {\n\t\tthrow stream.error('Unable to find matching \"}\" for curly brace at ' + stack.pop());\n\t}\n\n\treturn stream.current();\n}\n\n/**\n * Consumes integer from current stream position\n * @param  {StreamReader} stream\n * @return {Number}\n */\nfunction consumeIndex(stream) {\n\tstream.start = stream.pos;\n\tif (stream.eatWhile(isNumber)) {\n\t\treturn Number(stream.current());\n\t}\n}\n\nclass Field {\n\tconstructor(index, placeholder, location) {\n\t\tthis.index = index;\n\t\tthis.placeholder = placeholder;\n\t\tthis.location = location;\n\t\tthis.length = this.placeholder.length;\n\t}\n}\n\nclass FieldString {\n\t/**\n\t * @param {String} string\n\t * @param {Field[]} fields\n\t */\n\tconstructor(string, fields) {\n\t\tthis.string = string;\n\t\tthis.fields = fields;\n\t}\n\n\tmark(token) {\n\t\treturn mark(this.string, this.fields, token);\n\t}\n\n\ttoString() {\n\t\treturn string;\n\t}\n}\n\nexport { mark, createToken };export default parse;\n","import parseFields from '@emmetio/field-parser';\n\nconst defaultFieldsRenderer = text => text;\n\n/**\n * Output node is an object containing generated output for given Emmet\n * abbreviation node. Output node can be passed to various processors that\n * may shape-up final node output. The final output is simply a concatenation\n * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`\n * satellites\n * @param {Node}     node           Parsed Emmet abbreviation node\n * @param {Function} fieldsRenderer A function for rendering fielded text (text with\n * tabstops) for current node. @see ./render.js for details\n */\nclass OutputNode {\n\tconstructor(node, fieldsRenderer, options) {\n\t\tif (typeof fieldsRenderer === 'object') {\n\t\t\toptions = fieldsRenderer;\n\t\t\tfieldsRenderer = null;\n\t\t}\n\n\t\tthis.node = node;\n\t\tthis._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;\n\n\t\tthis.open = null;\n\t\tthis.beforeOpen = '';\n\t\tthis.afterOpen = '';\n\n\t\tthis.close = null;\n\t\tthis.beforeClose = '';\n\t\tthis.afterClose = '';\n\n\t\tthis.text = null;\n\t\tthis.beforeText = '';\n\t\tthis.afterText = '';\n\n\t\tthis.indent = '';\n\t\tthis.newline = '';\n\n\t\tif (options) {\n            Object.assign(this, options);\n        }\n\t}\n\n\tclone() {\n\t\treturn new this.constructor(this.node, this);\n\t}\n\n\t/**\n\t * Properly indents given multiline text\n\t * @param {String} text\n\t */\n\tindentText(text) {\n\t\tconst lines = splitByLines(text);\n        if (lines.length === 1) {\n            // no newlines, nothing to indent\n            return text;\n        }\n\n        // No newline and no indent means no formatting at all:\n        // in this case we should replace newlines with spaces\n        const nl = (!this.newline && !this.indent) ? ' ' : this.newline;\n        return lines.map((line, i) => i ? this.indent + line : line).join(nl);\n\t}\n\n\t/**\n\t * Renders given text with fields\n\t * @param {String} text\n\t * @return {String}\n\t */\n\trenderFields(text) {\n\t\treturn this._fieldsRenderer(text);\n\t}\n\n\ttoString(children) {\n\t\tconst open = this._wrap(this.open, this.beforeOpen, this.afterOpen);\n\t\tconst close = this._wrap(this.close, this.beforeClose, this.afterClose);\n\t\tconst text = this._wrap(this.text, this.beforeText, this.afterText);\n\n\t\treturn open + text + (children != null ? children : '') + close;\n\t}\n\n\t_wrap(str, before, after) {\n\t\tbefore = before != null ? before : '';\n\t\tafter = after != null ? after : '';\n\n        // automatically trim whitespace for non-empty wraps\n        if (str != null) {\n            str = before ? str.replace(/^\\s+/, '') : str;\n            str = after ? str.replace(/\\s+$/, '') : str;\n            return before + this.indentText(str) + after;\n        }\n\n        return '';\n\t}\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Default output of field (tabstop)\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, can be null\n * @return {String}\n */\nconst defaultField = (index, placeholder) => (placeholder || '');\n\n/**\n * Renders given parsed abbreviation `tree` via `formatter` function.\n\n * @param {Node}     tree      Parsed Emmet abbreviation\n * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)\n * @param {Function} formatter Output formatter function. It takes an output node—\n * a special wrapper for parsed node that holds formatting and output properties—\n * and updates its output properties to shape-up node’s output.\n * Function arguments:\n * \t– `outNode`: OutputNode\n * \t– `renderFields`: a helper function that parses fields/tabstops from given\n * \t   text and replaces them with `field` function output.\n * \t   It also takes care about field indicies and ensures that the same indicies\n * \t   from different nodes won’t collide\n */\nfunction render(tree, field, formatter) {\n    if (typeof formatter === 'undefined') {\n        formatter = field;\n        field = null;\n    }\n\n    field = field || defaultField;\n\n    // Each node may contain fields like `${1:placeholder}`.\n\t// Since most modern editors will link all fields with the same\n\t// index, we have to ensure that different nodes has their own indicies.\n\t// We’ll use this `fieldState` object to globally increment field indices\n\t// during output\n\tconst fieldState = { index: 1 };\n\n    const fieldsRenderer = text => text == null\n        ? field(fieldState.index++)\n        : getFieldsModel(text, fieldState).mark(field);\n\n\treturn run(tree.children, formatter, fieldsRenderer);\n}\n\nfunction run(nodes, formatter, fieldsRenderer) {\n\treturn nodes.map(node => {\n\t\tconst outNode = formatter(new OutputNode(node, fieldsRenderer));\n\t\treturn outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';\n\t}).join('');\n}\n\n/**\n * Returns fields (tab-stops) model with properly updated indices that won’t\n * collide with fields in other nodes of foprmatted tree\n * @param  {String|Object} text Text to get fields model from or model itself\n * @param  {Object} fieldState Abbreviation tree-wide field state reference\n * @return {Object} Field model\n */\nfunction getFieldsModel(text, fieldState) {\n\tconst model = typeof text === 'object' ? text : parseFields(text);\n    let largestIndex = -1;\n\n    model.fields.forEach(field => {\n\t\tfield.index += fieldState.index;\n\t\tif (field.index > largestIndex) {\n\t\t\tlargestIndex = field.index;\n\t\t}\n\t});\n\n\tif (largestIndex !== -1) {\n\t\tfieldState.index = largestIndex + 1;\n\t}\n\n    return model;\n}\n\nexport default render;\n","import parseFields from '@emmetio/field-parser';\nimport render from '@emmetio/output-renderer';\n\nconst TOKEN       = /^(.*?)([A-Z_]+)(.*?)$/;\nconst TOKEN_OPEN  = 91; // [\nconst TOKEN_CLOSE = 93; // ]\n\n/**\n * A basic templating engine.\n * Takes every `[TOKEN]` from given string and replaces it with\n * `TOKEN` value from given `data` attribute. The token itself may contain\n * various characters between `[`, token name and `]`. Contents of `[...]` will\n * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will\n * be replaced with actual value, all other characters will remain as is.\n *\n * Example:\n * ```\n * template('[<NAME>]', {NAME: 'foo'}) -> \"<foo>\"\n * template('[<NAME>]', {}) -> \"\"\n * ```\n */\nfunction template(str, data) {\n\tif (str == null) {\n\t\treturn str;\n\t}\n\n\t// NB since token may contain inner `[` and `]`, we can’t just use regexp\n\t// for replacement, should manually parse string instead\n\tconst stack = [];\n\tconst replacer = (str, left, token, right) =>\n\t\tdata[token] != null ? left + data[token] + right : '';\n\n\tlet output = '';\n\tlet offset = 0, i = 0;\n\tlet code, lastPos;\n\n\twhile (i < str.length) {\n\t\tcode = str.charCodeAt(i);\n\t\tif (code === TOKEN_OPEN) {\n\t\t\tstack.push(i);\n\t\t} else if (code === TOKEN_CLOSE) {\n\t\t\tlastPos = stack.pop();\n\t\t\tif (!stack.length) {\n\t\t\t\toutput += str.slice(offset, lastPos) +\n\t\t\t\t\tstr.slice(lastPos + 1, i).replace(TOKEN, replacer);\n\t\t\t\toffset = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn output + str.slice(offset);\n}\n\n/**\n * Various utility methods used by formatters\n */\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Check if given node is a first child in its parent\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isFirstChild(node) {\n\treturn node.parent.firstChild === node;\n}\n\n/**\n * Check if given node is a last child in its parent node\n * @param  {Node}  node\n * @return {Boolean}\n */\n\n\n/**\n * Check if given node is a root node\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRoot(node) {\n\treturn node && !node.parent;\n}\n\n/**\n * Check if given node is a pseudo-snippet: a text-only node with explicitly\n * defined children\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isPseudoSnippet(node) {\n    return node.isTextOnly && !!node.children.length;\n}\n\n/**\n * Handles pseudo-snippet node.\n * A pseudo-snippet is a text-only node with explicitly defined children.\n * For such case, we have to figure out if pseudo-snippet contains fields\n * (tab-stops) in node value and “split” it: make contents before field with\n * lowest index node’s “open” part and contents after lowest index — “close”\n * part. With this trick a final output will look like node’s children\n * are nested inside node value\n * @param  {OutputNode} outNode\n * @return {Boolean} Returns “true” if given node is a pseudo-snippets,\n * `false` otherwise\n */\nfunction handlePseudoSnippet(outNode) {\n\tconst node = outNode.node; // original abbreviaiton node\n\n\tif (isPseudoSnippet(node)) {\n\t\tconst fieldsModel = parseFields(node.value);\n\t\tconst field = findLowestIndexField(fieldsModel);\n\t\tif (field) {\n\t\t\tconst parts = splitFieldsModel(fieldsModel, field);\n            outNode.open = outNode.renderFields(parts[0]);\n\t\t\toutNode.close = outNode.renderFields(parts[1]);\n\t\t} else {\n\t\t\toutNode.text = outNode.renderFields(fieldsModel);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds field with lowest index in given text\n * @param  {Object} model\n * @return {Object}\n */\nfunction findLowestIndexField(model) {\n\treturn model.fields.reduce((result, field) =>\n\t\t!result || field.index < result.index ? field : result\n\t\t, null);\n}\n\n/**\n * Splits given fields model in two parts by given field\n * @param  {Object} model\n * @param  {Object} field\n * @return {Array} Two-items array\n */\nfunction splitFieldsModel(model, field) {\n\tconst ix = model.fields.indexOf(field);\n\n\tconst left = new model.constructor(\n\t\tmodel.string.slice(0, field.location),\n\t\tmodel.fields.slice(0, ix)\n\t);\n\n\tconst right = new model.constructor(\n\t\tmodel.string.slice(field.location + field.length),\n\t\tmodel.fields.slice(ix + 1)\n\t);\n\n\treturn [left, right];\n}\n\nconst commentOptions = {\n\t// enable node commenting\n\tenabled: false,\n\n\t// attributes that should trigger node commenting on specific node,\n\t// if commenting is enabled\n\ttrigger: ['id', 'class'],\n\n\t// comment before opening tag\n\tbefore: '',\n\n\t// comment after closing tag\n\tafter: '\\n<!-- /[#ID][.CLASS] -->'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as HTML, formatted according to\n * `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction html(tree, profile, options) {\n\toptions = Object.assign({}, options);\n\toptions.comment = Object.assign({}, commentOptions, options.comment);\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = setFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\tif (node.name) {\n\t\t\t\tconst name = profile.name(node.name);\n\t\t\t\tconst attrs = formatAttributes(outNode, profile);\n\n\t\t\t\toutNode.open = `<${name}${attrs}${node.selfClosing ? profile.selfClose() : ''}>`;\n\t\t\t\tif (!node.selfClosing) {\n\t\t\t\t\toutNode.close = `</${name}>`;\n\t\t\t\t}\n\n\t\t\t\tcommentNode(outNode, options.comment);\n\t\t\t}\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(node.value);\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction setFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n    if (shouldFormatNode(node, profile)) {\n        outNode.indent = profile.indent(getIndentLevel(node, profile));\n        outNode.newline = '\\n';\n        const prefix = outNode.newline + outNode.indent;\n\n        // do not format the very first node in output\n        if (!isRoot(node.parent) || !isFirstChild(node)) {\n            outNode.beforeOpen = prefix;\n            if (node.isTextOnly) {\n                outNode.beforeText = prefix;\n            }\n        }\n\n        if (hasInnerFormatting(node, profile)) {\n            if (!node.isTextOnly) {\n                outNode.beforeText = prefix + profile.indent(1);\n            }\n            outNode.beforeClose = prefix;\n        }\n    }\n\n    return outNode;\n}\n\n/**\n * Check if given node should be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatNode(node, profile) {\n\tif (!profile.get('format')) {\n\t\treturn false;\n\t}\n\n    if (node.parent.isTextOnly\n        && node.parent.children.length === 1\n        && parseFields(node.parent.value).fields.length) {\n        // Edge case: do not format the only child of text-only node,\n        // but only if parent contains fields\n        return false;\n    }\n\n\treturn isInline(node, profile) ? shouldFormatInline(node, profile) : true;\n}\n\n/**\n * Check if given inline node should be formatted as well, e.g. it contains\n * enough adjacent siblings that should force formatting\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatInline(node, profile) {\n\tif (!isInline(node, profile)) {\n\t\treturn false;\n\t}\n\n    if (isPseudoSnippet(node)) {\n        return true;\n    }\n\n    // check if inline node is the next sibling of block-level node\n    if (node.childIndex === 0) {\n        // first node in parent: format if it’s followed by a block-level element\n        let next = node;\n        while (next = next.nextSibling) {\n            if (!isInline(next, profile)) {\n                return true;\n            }\n        }\n    } else if (!isInline(node.previousSibling, profile)) {\n        // node is right after block-level element\n        return true;\n    }\n\n    if (profile.get('inlineBreak')) {\n        // check for adjacent inline elements before and after current element\n        let adjacentInline = 1;\n        let before = node, after = node;\n\n        while (isInlineElement((before = before.previousSibling), profile)) {\n            adjacentInline++;\n        }\n\n        while (isInlineElement((after = after.nextSibling), profile)) {\n            adjacentInline++;\n        }\n\n\t\tif (adjacentInline >= profile.get('inlineBreak')) {\n\t\t\treturn true;\n\t\t}\n    }\n\n\t// Another edge case: inline node contains node that should receive foramtting\n\tfor (let i = 0, il = node.children.length; i < il; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    return false;\n}\n\n/**\n * Check if given node contains inner formatting, e.g. any of its children should\n * be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction hasInnerFormatting(node, profile) {\n    // check if node if forced for inner formatting\n    const nodeName = (node.name || '').toLowerCase();\n    if (profile.get('formatForce').indexOf(nodeName) !== -1) {\n        return true;\n    }\n\n    // check if any of children should receive formatting\n    // NB don’t use `childrent.some()` to reduce memory allocations\n    for (let i = 0; i < node.children.length; i++) {\n        if (shouldFormatNode(node.children[i], profile)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Outputs attributes of given abbreviation node as HTML attributes\n * @param  {OutputNode} outNode\n * @param  {Profile}    profile\n * @return {String}\n */\nfunction formatAttributes(outNode, profile) {\n\tconst node = outNode.node;\n\n    return node.attributes.map(attr => {\n        if (attr.options.implied && attr.value == null) {\n    \t\treturn null;\n    \t}\n\n    \tconst attrName = profile.attribute(attr.name);\n    \tlet attrValue = null;\n\n        // handle boolean attributes\n    \tif (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {\n    \t\tif (profile.get('compactBooleanAttributes') && attr.value == null) {\n    \t\t\treturn ` ${attrName}`;\n    \t\t} else if (attr.value == null) {\n    \t\t\tattrValue = attrName;\n    \t\t}\n    \t}\n\n    \tif (attrValue == null) {\n    \t\tattrValue = outNode.renderFields(attr.value);\n    \t}\n\n    \treturn ` ${attrName}=${profile.quote(attrValue)}`;\n    }).join('');\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn (node && node.isTextOnly) || isInlineElement(node, profile);\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInlineElement(node, profile) {\n\treturn node && profile.isInline(node);\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * there’s a parent node with a name that is explicitly set to decrease level\n\tconst skip = profile.get('formatSkip') || [];\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\n/**\n * Comments given output node, if required\n * @param  {OutputNode} outNode\n * @param  {Object} options\n */\nfunction commentNode(outNode, options) {\n\tconst node = outNode.node;\n\n\tif (!options.enabled || !options.trigger || !node.name) {\n\t\treturn;\n\t}\n\n\tconst attrs = outNode.node.attributes.reduce((out, attr) => {\n\t\tif (attr.name && attr.value != null) {\n\t\t\tout[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;\n\t\t}\n\n\t\treturn out;\n\t}, {});\n\n\t// add comment only if attribute trigger is present\n\tfor (let i = 0, il = options.trigger.length; i < il; i++) {\n\t\tif (options.trigger[i].toUpperCase() in attrs) {\n\t\t\toutNode.open = template(options.before, attrs) + outNode.open;\n\t\t\tif (outNode.close) {\n\t\t\t\toutNode.close += template(options.after, attrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Common utility methods for indent-based syntaxes (Slim, Pug, etc.)\n */\n\nconst reId = /^id$/i;\nconst reClass = /^class$/i;\nconst defaultAttrOptions = {\n\tprimary: attrs => attrs.join(''),\n\tsecondary: attrs => attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${attr.value}`).join(', ')\n};\n\nconst defaultNodeOptions = {\n\topen: null,\n\tclose: null,\n\tomitName: /^div$/i,\n\tattributes: defaultAttrOptions\n};\n\nfunction indentFormat(outNode, profile, options) {\n\toptions = Object.assign({}, defaultNodeOptions, options);\n\tconst node = outNode.node;\n\n\toutNode.indent = profile.indent(getIndentLevel$1(node, profile));\n\toutNode.newline = '\\n';\n\n\t// Do not format the very first node in output\n    if (!isRoot(node.parent) || !isFirstChild(node)) {\n        outNode.beforeOpen = outNode.newline + outNode.indent;\n    }\n\n\tif (node.name) {\n\t\tconst data = Object.assign({\n\t\t\tNAME: profile.name(node.name),\n\t\t\tSELF_CLOSE: node.selfClosing ? options.selfClose : null\n\t\t}, getAttributes(outNode, profile, options.attributes));\n\n\t\t// omit tag name if node has primary attributes\n\t\tif (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {\n\t\t\tdata.NAME = null;\n\t\t}\n\n\t\tif (options.open != null) {\n\t\t\toutNode.open = template(options.open, data);\n\t\t}\n\n\t\tif (options.close != null) {\n\t\t\toutNode.close = template(options.close, data);\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats attributes of given node into a string.\n * @param  {OutputNode} node          Output node wrapper\n * @param  {Profile}    profile       Output profile\n * @param  {Object}     options       Additional formatting options\n * @return {String}\n */\nfunction getAttributes(outNode, profile, options) {\n\toptions = Object.assign({}, defaultAttrOptions, options);\n\tconst primary = [], secondary = [];\n\tconst node = outNode.node;\n\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst name = profile.attribute(attr.name);\n\t\tconst value = outNode.renderFields(attr.value);\n\n\t\tif (reId.test(name)) {\n\t\t\tvalue && primary.push(`#${value}`);\n\t\t} else if (reClass.test(name)) {\n\t\t\tvalue && primary.push(`.${value.replace(/\\s+/g, '.')}`);\n\t\t} else {\n\t\t\tconst isBoolean = attr.value == null\n\t\t\t\t&& (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);\n\n\t\t\tsecondary.push({ name, value, isBoolean });\n\t\t}\n\t});\n\n\treturn {\n\t\tPRIMARY_ATTRS: options.primary(primary) || null,\n\t\tSECONDARY_ATTRS: options.secondary(secondary) || null\n\t};\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel$1(node, profile) {\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tlevel++;\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\nconst reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as HAML, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction haml(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? `${attr.name}${profile.get('compactBooleanAttributes') ? '' : '=true'}`\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, HAML is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n/**\n * Formats value of given node: for multiline text we should add a ` |` suffix\n * at the end of each line. Also ensure that text is perfectly aligned.\n * @param  {Node}    node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst lines = splitByLines(node.value);\n\t\tconst indent = profile.indent(1);\n\t\tconst maxLength = lines.reduce((prev, line) => Math.max(prev, line.length), 0);\n\n\t\treturn lines.map((line, i) => `${i ? indent : ''}${pad(line, maxLength)} |`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nfunction pad(text, len) {\n\twhile (text.length < len) {\n\t\ttext += ' ';\n\t}\n\n\treturn text;\n}\n\nconst reNl$1 = /\\n|\\r/;\nconst secondaryAttrs = {\n\tnone:   '[ SECONDARY_ATTRS]',\n\tround:  '[(SECONDARY_ATTRS)]',\n\tcurly:  '[{SECONDARY_ATTRS}]',\n\tsquare: '[[SECONDARY_ATTRS]'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as Slim, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction slim(tree, profile, options) {\n\toptions = options || {};\n\tconst SECONDARY_ATTRS = options.attributeWrap\n\t\t&& secondaryAttrs[options.attributeWrap]\n\t\t|| secondaryAttrs.none;\n\n\tconst booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none\n\t\t? attr => `${attr.name}=true`\n\t\t: attr => attr.name;\n\n\tconst nodeOptions = {\n\t\topen: `[NAME][PRIMARY_ATTRS]${SECONDARY_ATTRS}[SELF_CLOSE]`,\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? booleanAttr(attr)\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, (outNode, renderFields) => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$1(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$1(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Slim is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$1(outNode, profile) {\n\tconst node = outNode.node;\n\tconst parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline$1(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl$1.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$1(node, profile) {\n\tif (node.value != null && reNl$1.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map((line, i) => `${indent}${i ? ' ' : '|'} ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline$1(node, profile) {\n\treturn node && (node.isTextOnly || profile.isInline(node));\n}\n\nconst reNl$2 = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as Pug, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction pug(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${profile.quote(attr.value)}`).join(', ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$2(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$2(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Pug is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$2(outNode, profile) {\n\tconst node = outNode.node;\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl$2.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$2(node, profile) {\n\tif (node.value != null && reNl$2.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map(line => `${indent}| ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nconst supportedSyntaxed = { html, haml, slim, pug };\n\n/**\n * Outputs given parsed abbreviation in specified syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nvar index = function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to HTML if given syntax is not supported\n\t\tsyntax = 'html';\n\t}\n\n\treturn supportedSyntaxed[syntax](tree, profile, options);\n};\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in supportedSyntaxed;\n}\n\nexport { supports };export default index;\n","import Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\nimport { eatQuoted, isAlpha, isNumber, isWhiteSpace } from '@emmetio/stream-reader-utils';\n\n/**\n * A wrapper for holding CSS value\n */\nclass CSSValue {\n\tconstructor() {\n\t\tthis.type = 'css-value';\n\t\tthis.value = [];\n\t}\n\n\tget size() {\n\t\treturn this.value.length;\n\t}\n\n\tadd(value) {\n\t\tthis.value.push(value);\n\t}\n\n\thas(value) {\n\t\treturn this.value.indexOf(value) !== -1;\n\t}\n\n\ttoString() {\n\t\treturn this.value.join(' ');\n\t}\n}\n\nconst HASH = 35; // #\nconst DOT  = 46; // .\n\n/**\n * Consumes a color token from given string\n * @param  {StreamReader} stream\n * @return {Color} Returns consumend color object, `undefined` otherwise\n */\nvar consumeColor = function(stream) {\n\t// supported color variations:\n\t// #abc   → #aabbccc\n\t// #0     → #000000\n\t// #fff.5 → rgba(255, 255, 255, 0.5)\n\t// #t     → transparent\n\tif (stream.peek() === HASH) {\n\t\tstream.start = stream.pos;\n\t\tstream.next();\n\n\t\tstream.eat(116) /* t */ || stream.eatWhile(isHex);\n\t\tconst base = stream.current();\n\n\t\t// a hex color can be followed by `.num` alpha value\n\t\tstream.start = stream.pos;\n\t\tif (stream.eat(DOT) && !stream.eatWhile(isNumber)) {\n\t\t\tthrow stream.error('Unexpected character for alpha value of color');\n\t\t}\n\n\t\treturn new Color(base, stream.current());\n\t}\n};\n\nclass Color {\n\tconstructor(value, alpha) {\n\t\tthis.type = 'color';\n\t\tthis.raw = value;\n\t\tthis.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);\n\t\tvalue = value.slice(1); // remove #\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tif (value === 't') {\n\t\t\tthis.alpha = 0;\n\t\t} else {\n\t\t\tswitch (value.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tr = g = b = value + value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tr = g = b = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tr = value[0] + value[0];\n\t\t\t\t\tg = value[1] + value[1];\n\t\t\t\t\tb = value[2] + value[2];\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tvalue += value;\n\t\t\t\t\tr = value.slice(0, 2);\n\t\t\t\t\tg = value.slice(2, 4);\n\t\t\t\t\tb = value.slice(4, 6);\n\t\t\t}\n\t\t}\n\n\t\tthis.r = parseInt(r, 16);\n\t\tthis.g = parseInt(g, 16);\n\t\tthis.b = parseInt(b, 16);\n\t}\n\n\t/**\n\t * Output current color as hex value\n\t * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible\n\t * @return {String}\n\t */\n\ttoHex(short) {\n\t\tconst fn = (short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b))\n\t\t\t? toShortHex : toHex;\n\n\t\treturn '#' + fn(this.r)  + fn(this.g) + fn(this.b);\n\t}\n\n\t/**\n\t * Output current color as `rgba?(...)` CSS color\n\t * @return {String}\n\t */\n\ttoRGB() {\n\t\tconst values = [this.r, this.g, this.b];\n\t\tif (this.alpha !== 1) {\n\t\t\tvalues.push(this.alpha.toFixed(8).replace(/\\.?0+$/, ''));\n\t\t}\n\n\t\treturn `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n\t}\n\n\ttoString(short) {\n\t\tif (!this.r && !this.g && !this.b && !this.alpha) {\n\t\t\treturn 'transparent';\n\t\t}\n\t\treturn this.alpha === 1 ? this.toHex(short) : this.toRGB();\n\t}\n}\n\n/**\n * Check if given code is a hex value (/0-9a-f/)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isHex(code) {\n\treturn isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\n\nfunction isShortHex(hex) {\n\treturn !(hex % 17);\n}\n\nfunction toShortHex(num) {\n\treturn (num >> 4).toString(16);\n}\n\nfunction toHex(num) {\n\treturn pad(num.toString(16), 2);\n}\n\nfunction pad(value, len) {\n\twhile (value.length < len) {\n\t\tvalue = '0' + value;\n\t}\n\treturn value;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumericWord(code) {\n\treturn isNumber(code) || isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaWord(code) {\n\treturn code === 95 /* _ */ || isAlpha(code);\n}\n\nconst PERCENT = 37; // %\nconst DOT$1     = 46; // .\nconst DASH$1    = 45; // -\n\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n * @param  {StreamReader} stream\n * @return {NumericValue}\n */\nvar consumeNumericValue = function(stream) {\n\tstream.start = stream.pos;\n\tif (eatNumber(stream)) {\n\t\tconst num = stream.current();\n\t\tstream.start = stream.pos;\n\n\t\t// eat unit, which can be a % or alpha word\n\t\tstream.eat(PERCENT) || stream.eatWhile(isAlphaWord);\n\t\treturn new NumericValue(num, stream.current());\n\t}\n};\n\n/**\n * A numeric CSS value with optional unit\n */\nclass NumericValue {\n\tconstructor(value, unit) {\n\t\tthis.type = 'numeric';\n\t\tthis.value = Number(value);\n\t\tthis.unit = unit || '';\n\t}\n\n\ttoString() {\n\t\treturn `${this.value}${this.unit}`;\n\t}\n}\n\n/**\n * Eats number value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean} Returns `true` if number was consumed\n */\nfunction eatNumber(stream) {\n\tconst start = stream.pos;\n\tconst negative = stream.eat(DASH$1);\n\tlet hadDot = false, consumed = false, code;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\t// either a second dot or not a number: stop parsing\n\t\tif (code === DOT$1 ? hadDot : !isNumber(code)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconsumed = true;\n\n\t\tif (code === DOT$1) {\n\t\t\thadDot = true;\n\t\t}\n\n\t\tstream.next();\n\t}\n\n\tif (negative && !consumed) {\n\t\t// edge case: consumed dash only, bail out\n\t\tstream.pos = start;\n\t}\n\n\treturn start !== stream.pos;\n}\n\nconst DOLLAR$1 = 36; // $\nconst DASH$2   = 45; // -\nconst AT$1     = 64; // @\n\n/**\n * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS\n * keyword or shorthand\n * @param  {StreamReader} stream\n * @param  {Boolean} [short] Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n * @return {String} Consumed variable\n */\nvar consumeKeyword = function(stream, short) {\n\tstream.start = stream.pos;\n\n\tif (stream.eat(DOLLAR$1) || stream.eat(AT$1)) {\n\t\t// SCSS or LESS variable\n\t\tstream.eatWhile(isVariableName);\n\t} else if (short) {\n\t\tstream.eatWhile(isAlphaWord);\n\t} else {\n\t\tstream.eatWhile(isKeyword);\n\t}\n\n\treturn stream.start !== stream.pos ? new Keyword(stream.current()) : null;\n};\n\nclass Keyword {\n\tconstructor(value) {\n\t\tthis.type = 'keyword';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nfunction isKeyword(code) {\n\treturn isAlphaNumericWord(code) || code === DASH$2;\n}\n\nfunction isVariableName(code) {\n\treturn code === 45 /* - */ || isAlphaNumericWord(code);\n}\n\nconst opt = { throws: true };\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @return {String}\n */\nvar consumeQuoted = function(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn new QuotedString(stream.current());\n\t}\n};\n\nclass QuotedString {\n\tconstructor(value) {\n\t\tthis.type = 'string';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nconst LBRACE = 40; // (\nconst RBRACE = 41; // )\nconst COMMA  = 44; // ,\n\n/**\n * Consumes arguments from given string.\n * Arguments are comma-separated list of CSS values inside round braces, e.g.\n * `(1, a2, 'a3')`. Nested lists and quoted strings are supported\n * @param  {StreamReader} stream\n * @return {Array}        Array of arguments, `null` if arguments cannot be consumed\n */\nfunction consumeArgumentList(stream) {\n\tif (!stream.eat(LBRACE)) {\n\t\t// not an argument list\n\t\treturn null;\n\t}\n\n\tlet level = 1, code, arg;\n\tconst argsList = [];\n\n\twhile (!stream.eof()) {\n\t\tif (arg = consumeArgument(stream)) {\n\t\t\targsList.push(arg);\n\t\t} else {\n\t\t\t// didn’t consumed argument, expect argument separator or end-of-arguments\n\t\t\tstream.eatWhile(isWhiteSpace);\n\n\t\t\tif (stream.eat(RBRACE)) {\n\t\t\t\t// end of arguments list\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!stream.eat(COMMA)) {\n\t\t\t\tthrow stream.error('Expected , or )');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn argsList;\n}\n\n/**\n * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be\n * a space-separated string of value\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeArgument(stream) {\n\tconst result = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\t\tvalue = consumeNumericValue(stream) || consumeColor(stream)\n\t\t\t|| consumeQuoted(stream) || consumeKeywordOrFunction(stream);\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tresult.add(value);\n\t}\n\n\treturn result.size ? result : null;\n}\n\n/**\n * Consumes either function call like `foo()` or keyword like `foo`\n * @param  {StreamReader} stream\n * @return {Keyword|FunctionCall}\n */\nfunction consumeKeywordOrFunction(stream) {\n\tconst kw = consumeKeyword(stream);\n\tif (kw) {\n\t\tconst args = consumeArgumentList(stream);\n\t\treturn args ? new FunctionCall(kw.toString(), args) : kw;\n\t}\n}\n\nclass FunctionCall {\n\t/**\n\t * @param {String} name Function name\n\t * @param {Array}  args Function arguments\n\t */\n\tconstructor(name, args) {\n\t\tthis.type = 'function';\n\t\tthis.name = name;\n\t\tthis.args = args || [];\n\t}\n\n\ttoString() {\n\t\treturn `${this.name}(${this.args.join(', ')})`;\n\t}\n}\n\nconst EXCL   = 33; // !\nconst DOLLAR = 36; // $\nconst PLUS   = 43; // +\nconst DASH   = 45; // -\nconst COLON  = 58; // :\nconst AT     = 64; // @\n\n/**\n * Parses given Emmet CSS abbreviation and returns it as parsed Node tree\n * @param {String} abbr\n * @return {Node}\n */\nvar index = function(abbr) {\n\tconst root = new Node();\n\tconst stream = new StreamReader(abbr);\n\tlet node;\n\n\twhile (!stream.eof()) {\n\t\tlet node = new Node(consumeIdent(stream));\n\t\tnode.value = consumeValue(stream);\n\n\t\tconst args = consumeArgumentList(stream);\n\t\tif (args) {\n\t\t\t// technically, arguments in CSS are anonymous Emmet Node attributes,\n\t\t\t// but since Emmet can support only one anonymous, `null`-name\n\t\t\t// attribute (for good reasons), we’ll use argument index as name\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tnode.setAttribute(String(i), args[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Consume `!important` modifier at the end of expression\n\t\tif (stream.eat(EXCL)) {\n\t\t\tnode.value.add('!');\n\t\t}\n\n\t\troot.appendChild(node);\n\n\t\t// CSS abbreviations cannot be nested, only listed\n\t\tif (!stream.eat(PLUS)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!stream.eof()) {\n\t\tthrow stream.error('Unexpected character');\n\t}\n\n\treturn root;\n};\n\n/**\n * Consumes CSS property identifier from given stream\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeIdent(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isIdentPrefix);\n\tstream.eatWhile(isIdent);\n\treturn stream.start !== stream.pos ? stream.current() : null;\n}\n\n/**\n * Consumes embedded value from Emmet CSS abbreviation stream\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeValue(stream) {\n\tconst values = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\t// use colon as value separator\n\t\tstream.eat(COLON);\n\t\tif (value = consumeNumericValue(stream) || consumeColor(stream)) {\n\t\t\t// edge case: a dash after unit-less numeric value or color should\n\t\t\t// be treated as value separator, not negative sign\n\t\t\tif (!value.unit) {\n\t\t\t\tstream.eat(DASH);\n\t\t\t}\n\t\t} else {\n\t\t\tstream.eat(DASH);\n\t\t\tvalue = consumeKeyword(stream, true);\n\t\t}\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\treturn values;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdent(code) {\n\treturn isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdentPrefix(code) {\n\treturn code === AT || code === DOLLAR || code === EXCL;\n}\n\nexport default index;\n","const DASH = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nvar stringScore = function(abbr, string) {\n    abbr = abbr.toLowerCase();\n    string = string.toLowerCase();\n    \n    if (abbr === string) {\n        return 1;\n    }\n\n    // a string MUST start with the same character as abbreviation\n    if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n        return 0;\n    }\n\n    const abbrLength = abbr.length;\n    const stringLength = string.length;\n    let i = 1, j = 1, score = stringLength;\n    let ch1, ch2, found, acronym;\n\n    while (i < abbrLength) {\n        ch1 = abbr.charCodeAt(i);\n        found = false;\n        acronym = false;\n\n        while (j < stringLength) {\n            ch2 = string.charCodeAt(j);\n\n            if (ch1 === ch2) {\n                found = true;\n                score += (stringLength - j) * (acronym ? 2 : 1);\n                break;\n            }\n\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === DASH;\n            j++;\n        }\n\n        if (!found) {\n            break;\n        }\n\n        i++;\n    }\n\n    return score && score * (i / abbrLength) / sum(stringLength);\n};\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nconst reProperty = /^([a-z\\-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nconst DASH$1 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nvar cssSnippets = function(snippets) {\n    return nest( snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)) );\n};\n\nclass CSSSnippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.property = null;\n\n        // detect if given snippet is a property\n        const m = value && value.match(reProperty);\n        if (m) {\n            this.property = m[1];\n            this.value = m[2];\n        }\n\n        this.dependencies = [];\n    }\n\n    addDependency(dep) {\n        this.dependencies.push(dep);\n    }\n\n    get defaulValue() {\n        return this.value != null ? splitValue(this.value)[0] : null;\n    }\n\n    /**\n     * Returns list of unique keywords for current CSS snippet and its dependencies\n     * @return {String[]}\n     */\n    keywords() {\n        const stack = [];\n        const keywords = new Set();\n        let i = 0, item, candidates;\n\n        if (this.property) {\n            // scan valid CSS-properties only\n            stack.push(this);\n        }\n\n        while (i < stack.length) {\n            // NB Keep items in stack instead of push/pop to avoid possible\n            // circular references\n            item = stack[i++];\n\n            if (item.value) {\n                candidates = splitValue(item.value).filter(isKeyword$1);\n\n                // extract possible keywords from snippet value\n                for (let j = 0; j < candidates.length; j++) {\n                    keywords.add(candidates[j].trim());\n                }\n\n                // add dependencies into scan stack\n                for (let j = 0, deps = item.dependencies; j < deps.length; j++) {\n                    if (stack.indexOf(deps[j]) === -1) {\n                        stack.push(deps[j]);\n                    }\n                }\n            }\n        }\n\n        return Array.from(keywords);\n    }\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n    snippets = snippets.sort(snippetsSort);\n    const stack = [];\n\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // backgound -> background-position -> background-position-x\n    for (let i = 0, cur, prev; i < snippets.length; i++) {\n        cur = snippets[i];\n\n        if (!cur.property) {\n            // not a CSS property, skip it\n            continue;\n        }\n\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n\n            if (cur.property.indexOf(prev.property) === 0\n                && cur.property.charCodeAt(prev.property.length) === DASH$1) {\n                prev.addDependency(cur);\n                stack.push(cur);\n                break;\n            }\n\n            stack.pop();\n        }\n\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n\n    return snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n\n    return a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword$1(str) {\n    return /^\\s*[\\w\\-]+/.test(str);\n}\n\nfunction splitValue(value) {\n    return String(value).split('|');\n}\n\nconst globalKeywords = ['auto', 'inherit', 'unset'];\nconst unitlessProperties = [\n    'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n    'flex', 'flex-grow', 'flex-shrink'\n];\n\nconst defaultOptions = {\n\tintUnit: 'px',\n\tfloatUnit: 'em',\n\tunitAliases: {\n\t\te :'em',\n\t\tp: '%',\n\t\tx: 'ex',\n\t\tr: 'rem'\n\t},\n\tfuzzySearchMinScore: 0\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nvar index = function(tree, registry, options) {\n\tconst snippets = convertToCSSSnippets(registry);\n\toptions = {\n\t\tintUnit: (options && options.intUnit) || defaultOptions.intUnit,\n\t\tfloatUnit: (options && options.floatUnit) || defaultOptions.floatUnit,\n\t\tunitAliases: Object.assign({}, defaultOptions.unitAliases, options && options.unitAliases),\n\t\tfuzzySearchMinScore: (options && options.fuzzySearchMinScore) || defaultOptions.fuzzySearchMinScore\n\t};\n\ttree.walk(node => resolveNode(node, snippets, options));\n\treturn tree;\n};\n\nfunction convertToCSSSnippets(registry) {\n    return cssSnippets(registry.all({type: 'string'}))\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @param  {Object} options\n * @return {Node}\n */\nfunction resolveNode(node, snippets, options) {\n\tconst snippet = findBestMatch(node.name, snippets, 'key', options.fuzzySearchMinScore);\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet, options)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS propery\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @param  {Object} formatOptions\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet, formatOptions) {\n    const abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tconst keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tlet kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n            if (!kw) {\n                // no matching value, try to get default one\n                kw = snippet.defaulValue;\n                if (kw && kw.indexOf('${') === -1) {\n                    // Quick and dirty test for existing field. If not, wrap\n                    // default value in a field\n                    kw = `\\${1:${kw}}`;\n                }\n            }\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (let i = 0, token; i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = `${!i ? '${1} ' : ''}!important`;\n\t\t\t\t} else if (isKeyword(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n                    token = resolveNumericValue(node.name, token, formatOptions);\n                }\n\n                node.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @param {Number} fuzzySearchMinScore The minimum score the best matched item should have to be a valid match.\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key, fuzzySearchMinScore) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tlet matchedItem = null;\n\tlet maxScore = 0;\n\tfuzzySearchMinScore = fuzzySearchMinScore || 0;\n\n\tfor (let i = 0, item; i < items.length; i++) {\n\t\titem = items[i];\n\t\tconst score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn maxScore >= fuzzySearchMinScore ? matchedItem : null;\n}\n\nfunction getScoringPart(item, key) {\n    const value = item && typeof item === 'object' ? item[key] : item;\n    const m = (value || '').match(/^[\\w-@]+/);\n    return m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasn’t found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (let i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n        lastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n    return tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @param  {Object} formatOptions Formatting options for units\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token, formatOptions) {\n    if (token.unit) {\n        token.unit = formatOptions.unitAliases[token.unit] || token.unit;\n    } else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n        // use `px` for integers, `em` for floats\n        // NB: num|0 is a quick alternative to Math.round(0)\n        token.unit = token.value === (token.value|0) ? formatOptions.intUnit : formatOptions.floatUnit;\n    }\n\n    return token;\n}\n\nexport { convertToCSSSnippets, stringScore, cssSnippets };export default index;\n","import render from '@emmetio/output-renderer';\nimport parseFields from '@emmetio/field-parser';\n\nconst defaultOptions = {\n\tshortHex: true,\n\tformat: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t}\n};\n\n/**\n * Renders given parsed Emmet CSS abbreviation as CSS-like\n * stylesheet, formatted according to `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction css(tree, profile, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\treturn render(tree, options.field, outNode => {\n\t\tconst node = outNode.node;\n\t\tlet value = String(node.value || '');\n\n\t\tif (node.attributes.length) {\n\t\t\tconst fieldValues = node.attributes.map(attr => stringifyAttribute(attr, options));\n\t\t\tvalue = injectFields(value, fieldValues);\n\t\t}\n\n\t\toutNode.open = node.name && profile.name(node.name);\n\t\toutNode.afterOpen = options.format.between;\n\t\toutNode.text = outNode.renderFields(value || null);\n\n\t\tif (outNode.open && (!outNode.text || !outNode.text.endsWith(';'))) {\n\t\t\toutNode.afterText = options.format.after;\n\t\t}\n\n\t\tif (profile.get('format')) {\n\t\t\toutNode.newline = '\\n';\n\t\t\tif (tree.lastChild !== node) {\n\t\t\t\toutNode.afterText += outNode.newline;\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Injects given field values at each field of given string\n * @param  {String}   string\n * @param  {String[]} attributes\n * @return {FieldString}\n */\nfunction injectFields(string, values) {\n\tconst fieldsModel = parseFields(string);\n\tconst fieldsAmount = fieldsModel.fields.length;\n\n\tif (fieldsAmount) {\n\t\tvalues = values.slice();\n\t\tif (values.length > fieldsAmount) {\n\t\t\t// More values that output fields: collapse rest values into\n\t\t\t// a single token\n\t\t\tvalues = values.slice(0, fieldsAmount - 1)\n\t\t\t\t.concat(values.slice(fieldsAmount - 1).join(', '));\n\t\t}\n\n\t\twhile (values.length) {\n\t\t\tconst value = values.shift();\n\t\t\tconst field = fieldsModel.fields.shift();\n\t\t\tconst delta = value.length - field.length;\n\n\t\t\tfieldsModel.string = fieldsModel.string.slice(0, field.location)\n\t\t\t\t+ value\n\t\t\t\t+ fieldsModel.string.slice(field.location + field.length);\n\n\t\t\t// Update location of the rest fields in string\n\t\t\tfor (let i = 0, il = fieldsModel.fields.length; i < il; i++) {\n\t\t\t\tfieldsModel.fields[i].location += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fieldsModel;\n}\n\nfunction stringifyAttribute(attr, options) {\n\tif (attr.value && typeof attr.value === 'object' && attr.value.type === 'css-value') {\n\t\treturn attr.value.value\n\t\t.map(token => {\n\t\t\tif (token && typeof token === 'object') {\n\t\t\t\treturn token.type === 'color'\n\t\t\t\t\t? token.toString(options.shortHex)\n\t\t\t\t\t: token.toString();\n\t\t\t}\n\n\t\t\treturn String(token);\n\t\t})\n\t\t.join(' ');\n\t}\n\n\treturn attr.value != null ? String(attr.value) : '';\n}\n\nconst syntaxFormat = {\n\tcss: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t},\n\tscss: 'css',\n\tless: 'css',\n\tsass: {\n\t\tbetween: ': ',\n\t\tafter: ''\n\t},\n\tstylus: {\n\t\tbetween: ' ',\n\t\tafter: ''\n\t}\n};\n\n/**\n * Outputs given parsed abbreviation in specified stylesheet syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nvar index = function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to CSS if given syntax is not supported\n\t\tsyntax = 'css';\n\t}\n\n\toptions = Object.assign({}, options, {\n\t\tformat: getFormat(syntax, options)\n\t});\n\n\t// CSS abbreviations doesn’t support nesting so simply\n\t// output root node children\n\treturn css(tree, profile, options);\n};\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in syntaxFormat;\n}\n\n/**\n * Returns formatter object for given syntax\n * @param  {String} syntax\n * @param  {Object} [options]\n * @return {Object} Formatter object as defined in `syntaxFormat`\n */\nfunction getFormat(syntax, options) {\n\tlet format = syntaxFormat[syntax];\n\tif (typeof format === 'string') {\n\t\tformat = syntaxFormat[format];\n\t}\n\n\treturn Object.assign({}, format, options && options.stylesheet);\n}\n\nexport { supports };export default index;\n","var html = {\n\t\"a\": \"a[href]\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"style\": \"style\",\n\t\"script\": \"script[!src]\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n    \"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar css = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:flex-start|flex-end|center|space-between|space-around|stretch\",\n\t\"ai\": \"align-items:flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:${1:time}\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:#${1:000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:#${1:000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:#${1:000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:#${1:000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:#${1:000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:#${1:000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} #${5:000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:#${1:000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fz\": \"font-size\",\n\t\"fza\": \"font-size-adjust\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:flex-start|flex-end|center|space-between|space-around\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:#${1:000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xsl = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar index = { html, css, xsl };\n\nexport default index;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst langs = { latin, ru, sp };\n\nconst defaultOptions = {\n\twordCount: 30,\n\tskipCommon: false,\n\tlang: 'latin'\n};\n\n/**\n * Replaces given parsed Emmet abbreviation node with nodes filled with\n * Lorem Ipsum stub text.\n * @param {Node} node\n * @return {Node}\n */\nvar index = function(node, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst dict = langs[options.lang] || langs.latin;\n    const startWithCommon = !options.skipCommon && !isRepeating(node);\n\n\tif (!node.repeat && !isRoot(node.parent)) {\n\t\t// non-repeating element, insert text stub as a content of parent node\n\t\t// and remove current one\n\t\tnode.parent.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.remove();\n\t} else {\n\t\t// Replace named node with generated content\n\t\tnode.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.name = node.parent.name ? resolveImplicitTag(node.parent.name) : null;\n\t}\n\n\treturn node;\n};\n\nfunction isRoot(node) {\n\treturn !node.parent;\n}\n\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n * @param {Number} from\n * @param {Number} to\n * @returns {Number}\n */\nfunction rand(from, to) {\n\treturn Math.floor(Math.random() * (to - from) + from);\n}\n\n/**\n * @param {Array} arr\n * @param {Number} count\n * @returns {Array}\n */\nfunction sample(arr, count) {\n\tconst len = arr.length;\n\tconst iterations = Math.min(len, count);\n\tconst result = new Set();\n\n\twhile (result.size < iterations) {\n\t\tresult.add(arr[rand(0, len)]);\n\t}\n\n\treturn Array.from(result);\n}\n\nfunction choice(val) {\n\treturn val[rand(0, val.length - 1)];\n}\n\nfunction sentence(words, end) {\n\tif (words.length) {\n\t\twords = [capitalize(words[0])].concat(words.slice(1));\n\t}\n\n\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\n\nfunction capitalize(word) {\n\treturn word[0].toUpperCase() + word.slice(1);\n}\n\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside <code>words</code> array\n * @param {Array} words\n */\nfunction insertCommas(words) {\n\tif (words.length < 2) {\n\t\treturn words;\n\t}\n\n\twords = words.slice();\n\tconst len = words.length;\n\tconst hasComma = /,$/;\n\tlet totalCommas = 0;\n\n\tif (len > 3 && len <= 6) {\n\t\ttotalCommas = rand(0, 1);\n\t} else if (len > 6 && len <= 12) {\n\t\ttotalCommas = rand(0, 2);\n\t} else {\n\t\ttotalCommas = rand(1, 4);\n\t}\n\n\tfor (let i = 0, pos, word; i < totalCommas; i++) {\n\t\tpos = rand(0, len - 2);\n\t\tif (!hasComma.test(words[pos])) {\n\t\t\twords[pos] += ',';\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param {Object} dict Words dictionary (see `lang/*.json`)\n * @param {Number} wordCount Words count in paragraph\n * @param {Boolean} startWithCommon Should paragraph start with common\n * \"lorem ipsum\" sentence.\n * @returns {String}\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n\tconst result = [];\n\tlet totalWords = 0;\n\tlet words;\n\n\tif (startWithCommon && dict.common) {\n\t\twords = dict.common.slice(0, wordCount);\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words), '.'));\n\t}\n\n\twhile (totalWords < wordCount) {\n\t\twords = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words)));\n\t}\n\n\treturn result.join(' ');\n}\n\n/**\n * Check if given node is in repeating context, e.g. node itself or one of its\n * parent is repeated\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRepeating(node) {\n    while (node.parent) {\n        if (node.repeat && node.repeat.value && node.repeat.value > 1) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\nexport default index;\n","import Profile from '@emmetio/output-profile';\nimport SnippetsRegistry from '@emmetio/snippets-registry';\nimport parseAbbreviation from '@emmetio/abbreviation';\nimport resolveSnippets from '@emmetio/html-snippets-resolver';\nimport transform from '@emmetio/html-transform';\nimport resolveVariables from '@emmetio/variable-resolver';\nimport format from '@emmetio/markup-formatters';\nimport parseAbbreviation$1 from '@emmetio/css-abbreviation';\nimport resolveSnippets$1 from '@emmetio/css-snippets-resolver';\nimport format$1 from '@emmetio/stylesheet-formatters';\nimport defaultSnippets from '@emmetio/snippets';\nimport lorem from '@emmetio/lorem';\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {String}\n */\nfunction expand$1(abbr, options) {\n\toptions = options || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$1(abbr, options);\n\t}\n\n\treturn format(abbr, options.profile, options.syntax, options.format);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String} Abbreviation to parse\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$1(abbr, options) {\n\treturn parseAbbreviation(abbr)\n\t.use(resolveSnippets, options.snippets)\n\t.use(resolveVariables, options.variables)\n\t.use(transform, options.text, options.addons);\n}\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {String}\n */\nfunction expand$2(abbr, options) {\n\toptions = options || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$2(abbr, options);\n\t}\n\n\treturn format$1(abbr, options.profile, options.syntax, options.format);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String|Node} Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$2(abbr, options) {\n\tif (typeof abbr === 'string') {\n\t\tabbr = parseAbbreviation$1(abbr);\n\t}\n\n\treturn abbr.use(resolveSnippets$1, options.snippets, options.format ? options.format.stylesheet : {});\n}\n\nconst reLorem = /^lorem([a-z]*)(\\d*)$/;\n\n/**\n * Constructs a snippets registry, filled with snippets, for given options\n * @param  {String} syntax  Abbreviation syntax\n * @param  {Object|Object[]} snippets Additional snippets\n * @return {SnippetsRegistry}\n */\nvar snippetsRegistryFactory = function(syntax, snippets) {\n\tconst registrySnippets = [defaultSnippets[syntax] || defaultSnippets.html];\n\n\tif (Array.isArray(snippets)) {\n\t\tsnippets.forEach(item => {\n\t\t\t// if array item is a string, treat it as a reference to globally\n\t\t\t// defined snippets\n\t\t\tregistrySnippets.push(typeof item === 'string' ? defaultSnippets[item] : item);\n\t\t});\n\t} else if (typeof snippets === 'object') {\n\t\tregistrySnippets.push(snippets);\n\t}\n\n\tconst registry = new SnippetsRegistry(registrySnippets.filter(Boolean));\n\n\t// for non-stylesheet syntaxes add Lorem Ipsum generator\n\tif (syntax !== 'css') {\n\t\tregistry.get(0).set(reLorem, loremGenerator);\n\t}\n\n\treturn registry;\n};\n\nfunction loremGenerator(node) {\n\tconst options = {};\n\tconst m = node.name.match(reLorem);\n\tif (m[1]) {\n\t\toptions.lang = m[1];\n\t}\n\n\tif (m[2]) {\n\t\toptions.wordCount = +m[2];\n\t}\n\n\treturn lorem(node, options);\n}\n\n/**\n * Default variables used in snippets to insert common values into predefined snippets\n * @type {Object}\n */\nconst defaultVariables = {\n\tlang: 'en',\n\tlocale: 'en-US',\n\tcharset: 'UTF-8'\n};\n\n/**\n * A list of syntaxes that should use Emmet CSS abbreviations:\n * a variations of default abbreivation that holds values right in abbreviation name\n * @type {Set}\n */\nconst stylesheetSyntaxes = new Set(['css', 'sass', 'scss', 'less', 'stylus', 'sss']);\n\nconst defaultOptions = {\n\t/**\n\t * Abbreviation output syntax\n\t * @type {String}\n\t */\n\tsyntax: 'html',\n\n\t/**\n\t * Field/tabstop generator for editor. Most editors support TextMate-style\n\t * fields: ${0} or ${1:item}. So for TextMate-style fields this function\n\t * will look like this:\n\t * @example\n\t * (index, placeholder) => `\\${${index}${placeholder ? ':' + placeholder : ''}}`\n\t *\n\t * @param  {Number} index         Placeholder index. Fields with the same indices\n\t * should be linked\n\t * @param  {String} [placeholder] Field placeholder\n\t * @return {String}\n\t */\n\tfield: (index, placeholder) => placeholder || '',\n\n\t/**\n\t * Insert given text string(s) into expanded abbreviation\n\t * If array of strings is given, the implicitly repeated element (e.g. `li*`)\n\t * will be repeated by the amount of items in array\n\t * @type {String|String[]}\n\t */\n\ttext: null,\n\n\t/**\n\t * Either predefined output profile or options for output profile. Used for\n\t * abbreviation output\n\t * @type {Profile|Object}\n\t */\n\tprofile: null,\n\n\t/**\n\t * Custom variables for variable resolver\n\t * @see @emmetio/variable-resolver\n\t * @type {Object}\n\t */\n\tvariables: {},\n\n\t/**\n\t * Custom predefined snippets for abbreviation. The expanded abbreviation\n\t * will try to match given snippets that may contain custom elements,\n\t * predefined attributes etc.\n\t * May also contain array of items: either snippets (Object) or references\n\t * to default syntax snippets (String; the key in default snippets hash)\n\t * @see @emmetio/snippets\n\t * @type {Object|SnippetsRegistry}\n\t */\n\tsnippets: {},\n\n\t/**\n\t * Hash of additional transformations that should be applied to expanded\n\t * abbreviation, like BEM or JSX. Since these transformations introduce\n\t * side-effect, they are disabled by default and should be enabled by\n\t * providing a transform name as a key and transform options as value:\n\t * @example\n\t * {\n\t *     bem: {element: '--'},\n\t *     jsx: true // no options, just enable transform\n\t * }\n\t * @see @emmetio/html-transform/lib/addons\n\t * @type {Object}\n\t */\n\taddons: null,\n\n\t/**\n\t * Additional options for syntax formatter\n\t * @see @emmetio/markup-formatters\n\t * @type {Object}\n\t */\n\tformat: null\n};\n\n/**\n * Expands given abbreviation into string, formatted according to provided\n * syntax and options\n * @param  {String|Node} abbr        Abbreviation string or parsed abbreviation tree\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {String}\n */\nfunction expand$$1(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn isStylesheet(options.syntax)\n\t\t? expand$2(abbr, options)\n\t\t: expand$1(abbr, options);\n}\n\n/**\n * Parses given abbreviation into AST tree. This tree can be later formatted to\n * string with `expand` function\n * @param  {String} abbr             Abbreviation to parse\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {Node}\n */\nfunction parse$$1(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn isStylesheet(options.syntax)\n\t\t? parse$2(abbr, options)\n\t\t: parse$1(abbr, options);\n}\n\n/**\n * Creates snippets registry for given syntax and additional `snippets`\n * @param  {String} syntax   Snippets syntax, used for retreiving predefined snippets\n * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction createSnippetsRegistry(syntax, snippets) {\n\treturn snippets instanceof SnippetsRegistry\n\t\t? snippets\n\t\t: snippetsRegistryFactory(isStylesheet(syntax) ? 'css' : syntax, snippets);\n}\n\nfunction createOptions(options) {\n\tif (typeof options === 'string') {\n\t\toptions = { syntax: options };\n\t}\n\n\toptions = Object.assign({}, defaultOptions, options);\n\toptions.format = Object.assign({field: options.field}, options.format);\n\toptions.profile = createProfile(options);\n\toptions.variables = Object.assign({}, defaultVariables, options.variables);\n\toptions.snippets = createSnippetsRegistry(isStylesheet(options.syntax) ? 'css' : options.syntax, options.snippets);\n\n\treturn options;\n}\n\n/**\n * Check if given syntax belongs to stylesheet markup.\n * Emmet uses different abbreviation flavours: one is a default markup syntax,\n * used for HTML, Slim, Pug etc, the other one is used for stylesheets and\n * allows embedded values in abbreviation name\n * @param  {String}  syntax\n * @return {Boolean}\n */\nfunction isStylesheet(syntax) {\n\treturn stylesheetSyntaxes.has(syntax);\n}\n\n/**\n * Creates output profile from given options\n * @param  {Object} options\n * @return {Profile}\n */\nfunction createProfile(options) {\n\treturn options.profile instanceof Profile\n\t\t? options.profile\n\t\t: new Profile(options.profile);\n}\n\nexport { expand$$1 as expand, parse$$1 as parse, createSnippetsRegistry, createOptions, isStylesheet, createProfile };\n","'use strict';\n\n/**\n * Syntaxes known by Emmet. All other syntaxes shoud map to one of these\n * @type {Set}\n */\nconst knownSyntaxes = new Set([\n\t'html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml',\n\t'css', 'sass', 'scss', 'less', 'sss', 'stylus'\n]);\n\n/**\n * Common context checker for abbreviation auto-activation for\n * stylesheet syntaxes (CSS, SCSS, LESS etc.)\n * @param  {CodeMirror} editor\n * @return {Boolean}\n */\nconst stylesheetAutoActivationContext = (editor, pos) => {\n\tconst tokenType = editor.getTokenTypeAt(pos || editor.getCursor());\n\t// NB may return `property` or `property error` type\n\treturn tokenType && /^property\\b/.test(tokenType);\n};\n\nconst autoActivationContext = {\n\thtml(editor, pos) {\n\t\t// Do not provide automatic abbreviation completion inside HTML tags,\n\t\t// e.g. work only inside plain text token\n\t\treturn editor.getTokenTypeAt(pos || editor.getCursor()) === null;\n\t},\n\n\tcss:  stylesheetAutoActivationContext,\n\tless: stylesheetAutoActivationContext,\n\tsass: stylesheetAutoActivationContext,\n\tscss: stylesheetAutoActivationContext\n};\n\n/**\n * Detect Emmet syntax from given editor’s position.\n * @param {CodeMirror}     editor\n * @param {CodeMirror.Pos} [pos]\n * @return {String}        Returns `null` if Emmet syntax can’t be detected\n */\nexport default function detectSyntax(editor, pos) {\n\tconst mode = editor.getModeAt(pos || editor.getCursor());\n\tconst syntax = mode.name === 'xml' ? 'html' : mode.name;\n\n\tif (isSupported(syntax)) {\n\t\treturn syntax;\n\t}\n\n\t// No supported syntax found, try from Emmet-specific options\n\tconst emmetOpt = editor.getOption('emmet');\n\tif (emmetOpt && isSupported(emmetOpt.syntax)) {\n\t\treturn emmetOpt.syntax;\n\t}\n\n\treturn null;\n}\n\n/**\n * Check if given syntax is supported by Emmet\n * @param  {String}  syntax\n * @return {Boolean}\n */\nexport function isSupported(syntax) {\n\treturn knownSyntaxes.has(syntax);\n}\n\n/**\n * Check if current editor’s context (syntax, scope) allows automatic Emmet\n * abbreviation activation as user types text. If this function returns `false`,\n * it is recommended to not create any Emmet completions when user types text,\n * but insert them when user activated autocomplete popup manually\n * @param  {CodeMirror}  editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {Boolean}\n */\nexport function hasAutoActivateContext(editor, pos) {\n\tconst syntax = detectSyntax(editor, pos);\n\treturn syntax && (!autoActivationContext[syntax] || autoActivationContext[syntax](editor, pos));\n}\n","'use strict';\n\nimport StreamReader from '@emmetio/stream-reader';\nimport { comparePos } from './utils';\n\nconst LINE_END = 10; // \\n\n\n/**\n * A stream reader for CodeMirror editor\n */\nexport default class CodeMirrorStreamReader extends StreamReader {\n\t/**\n\t * @param  {CodeMirror}       editor\n\t * @param  {CodeMirror.Pos}   [pos]\n\t * @param  {CodeMirror.Range} [limit]\n\t */\n\tconstructor(editor, pos, limit) {\n\t\tsuper();\n\t\tconst CodeMirror = editor.constructor;\n\t\tthis.editor = editor;\n\t\tthis.start = this.pos = pos || CodeMirror.Pos(0, 0);\n\n\t\tconst lastLine = editor.lastLine();\n\t\tthis._eof = limit ? limit.to   : CodeMirror.Pos(lastLine, this._lineLength(lastLine));\n\t\tthis._sof = limit ? limit.from : CodeMirror.Pos(0, 0);\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the beginning of the file.\n\t * @returns {Boolean}\n\t */\n\tsof() {\n\t\treturn comparePos(this.pos, this._sof) <= 0;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn comparePos(this.pos, this._eof) >= 0;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * points for underlying buffer\n\t * @param  {CodeMirror.Pos} start\n\t * @param  {CodeMirror.Pos} end\n\t * @return {CodeMirrorStreamReader}\n\t */\n\tlimit(from, to) {\n\t\treturn new this.constructor(this.editor, from, { from, to });\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\tconst { line, ch } = this.pos;\n\t\tconst lineStr = this.editor.getLine(this.pos.line);\n\t\treturn ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns NaN when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (!this.eof()) {\n\t\t\tconst code = this.peek();\n\t\t\tthis.pos = Object.assign({}, this.pos, { ch: this.pos.ch + 1 });\n\n\t\t\tif (this.pos.ch >= this._lineLength(this.pos.line)) {\n\t\t\t\tthis.pos.line++;\n\t\t\t\tthis.pos.ch = 0;\n\t\t\t}\n\n\t\t\tif (this.eof()) {\n\t\t\t\t// handle edge case where position can move on next line\n\t\t\t\t// after EOF\n\t\t\t\tthis.pos = Object.assign({}, this._eof);\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tconst CodeMirror = this.editor.constructor;\n\n\t\tlet { line, ch } = this.pos;\n\t\tch -= (n || 1);\n\n\t\twhile (line >= 0 && ch < 0) {\n\t\t\tline--;\n\t\t\tch += this._lineLength(line);\n\t\t}\n\n\t\tthis.pos = line < 0 || ch < 0\n\t\t\t? CodeMirror.Pos(0, 0)\n\t\t\t: CodeMirror.Pos(line, ch);\n\n\t\treturn this.peek();\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns contents for given range\n\t * @param  {Point} from\n\t * @param  {Point} to\n\t * @return {String}\n\t */\n\tsubstring(from, to) {\n\t\treturn this.editor.getRange(from, to);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at line ${this.pos.line}, column ${this.pos.ch}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n\n\t/**\n\t * Returns length of given line, including line ending\n\t * @param  {Number} line\n\t * @return {Number}\n\t */\n\t_lineLength(line) {\n\t\tconst isLast = line === this.editor.lastLine();\n\t\treturn this.editor.getLine(line).length + (isLast ? 0 : 1);\n\t}\n}\n","import CodeMirrorStreamReader from \"./stream-reader\";\nimport { isSpace } from \"@emmetio/stream-reader-utils\";\n\n'use strict';\n\n/**\n * Returns token used for single indentation in given editor\n * @param  {CodeMirror} editor\n * @return {String}\n */\nexport function getIndentation(editor) {\n\tif (!editor.getOption('indentWithTabs')) {\n\t\treturn repeatString(' ', editor.getOption('indentUnit'));\n\t}\n\n\treturn '\\t';\n}\n\n/**\n * Normalizes text according to given CodeMirror instance indentation\n * preferences\n * @param  {String}     text\n * @param  {CodeMirror} editor\n * @param  {String}     [indentation] Applies `indentText()` with given argument,\n *                                    if provided\n * @return {String}\n */\nexport function normalizeText(editor, text, indentation) {\n\tlet lines = splitByLines(text);\n\tconst indent = getIndentation(editor);\n\n\tif (indent !== '\\t') {\n\t\tlines = lines.map(line => line.replace(/^\\t+/,\n\t\t\ttabs => repeatString(indent, tabs.length)));\n\t}\n\n\tif (indentation) {\n\t\tlines = lines.map((line, i) => i ? indentation + line : line);\n\t}\n\n\treturn lines.join('\\n');\n}\n\n/**\n * Indents each line, except first one, in given text\n * @param  {String} text\n * @param  {String} indentation\n * @return {String}\n */\nexport function indentText(text, indentation) {\n\treturn splitByLines(text)\n\t.map((line, i) => i ? indentation + line : line)\n\t.join('\\n');\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]} Lines of text\n */\nexport function splitByLines(text) {\n\treturn Array.isArray(text) ? text : text.split(/\\r\\n|\\r|\\n/g);\n}\n\nexport function repeatString(str, count) {\n\tlet result = '';\n\twhile (0 < count--) {\n\t\tresult += str;\n\t}\n\n\treturn result;\n}\n\n/**\n * Quick and dirty way to remove fields from given string\n * @param  {String} str\n * @return {String}\n */\nexport function removeFields(str) {\n\treturn str.replace(/\\$\\{\\d+(:[^\\}]+)?\\}/g, '');\n}\n\n/**\n * Check if given range contains point\n * @param  {CodeMirror.Range} range\n * @param  {CodeMirror.Pos} pos\n * @param  {Boolean} [exclude] Exclude range and and start\n * @return {Boolean}\n */\nexport function containsPos(range, pos, exclude) {\n\treturn exclude\n\t\t? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n\t\t: comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\n\nexport function comparePos(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n\nexport function rangeFromNode(node) {\n\treturn {\n\t\tfrom: node.start,\n\t\tto: node.end\n\t};\n}\n\n/**\n * Narrows given `{from, to}` range to first non-whitespace characters in given \n * editor content\n * @param {CodeMirror} editor \n * @param {CodeMirror.Pos} from \n * @param {CodeMirror.Pos} [to] \n * @returns {Object}\n */\nexport function narrowToNonSpace(editor, from, to) {\n\tconst stream = new CodeMirrorStreamReader(editor, from);\n\n\tstream.eatWhile(isSpace);\n\tfrom = stream.pos;\n\t\n\tif (to) {\n\t\tstream.pos = to;\n\t\tstream.backUp();\n\n\t\twhile (!stream.sof() && isSpace(stream.peek())) {\n\t\t\tstream.backUp();\n\t\t}\n\n\t\tstream.next();\n\t\tto = stream.pos;\n\t} else {\n\t\tto = from;\n\t}\n\n\treturn { from, to };\n}\n","'use strict';\n\nimport extract from '@emmetio/extract-abbreviation';\nimport { expand, parse, isStylesheet } from '@emmetio/expand-abbreviation';\nimport detectSyntax from './detect-syntax';\nimport { normalizeText } from './utils';\n\nconst cursorMark = '[[::emmet-cursor::]]';\n\n// NB CodeMirror doesn’t natively supports tabstops\nconst editorField = (index, placeholder = '') => placeholder;\n\n/**\n * Expands given abbreviation for given editor.\n * The editor is used to detect abbreviation syntax and provide\n * tag context for markup abbreviations\n * @param  {String|Node} abbr\n * @param  {CodeMirror}  editor\n * @return {String}\n * @throws Error if abbreviation is invalid\n */\nexport default function expandAbbreviation(abbr, editor, options) {\n\treturn expand(abbr, Object.assign({\n\t\tsyntax: detectSyntax(editor),\n\t\tfield: editorField\n\t}, getExpandOptions(editor), options));\n}\n\n/**\n * Parses abbreviation for given editor\n * @param  {String} abbr\n * @param  {CodeMirror} editor\n * @return {Node}\n * @throws Error if abbreviation is invalid\n */\nexport function parseAbbreviation(abbr, editor) {\n\treturn parse(abbr, Object.assign({\n\t\tsyntax: detectSyntax(editor),\n\t}, getExpandOptions(editor)));\n}\n\n/**\n * Extracts abbreviation from given position of editor\n * @param  {CodeMirror}     editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {Object}         Object with `{abbreviation, location}` properties or `null`\n */\nexport function extractAbbreviation(editor, pos) {\n\tpos = pos || pos.getCursor();\n\tconst line = editor.getLine(pos.line);\n\n\treturn extract(line, pos.ch, true);\n}\n\n/**\n * Returns abbreviation model: object with `ast` and `snippet` properties\n * that contains parsed and expanded abbreviation respectively\n * @param  {String} abbreviation\n * @param  {CodeMirror} editor\n * @return {Object} Returns `null` if abbreviation cannot be parsed\n */\nexport function createAbbreviationModel(abbreviation, editor) {\n\ttry {\n\t\tconst ast = parseAbbreviation(abbreviation, editor);\n\t\treturn {\n\t\t\tast,\n\t\t\tabbreviation,\n\t\t\tsnippet: expandAbbreviation(abbreviation, editor)\n\t\t};\n\t} catch (err) {\n\t\t// console.warn('Unable to build Emmet abbreviation model', err);\n\t\treturn null;\n\t}\n}\n\n/**\n * Expands given abbreviation and inserts expanded result into editor, maintaining\n * proper indentation and final cursor position\n * @param  {CodeMirror} editor CodeMirror editor instance\n * @param  {String|Object} abbr  Abbreviation to expand (string or parsed)\n * @param  {CodeMirror.Range} range Location of abbreviation in editor\n * @param  {Object} [options] Additional abbreviation expander options\n * @return {Boolean} Returns `true` if abbreviation was successfully expanded and inserted\n */\nexport function expandAndInsert(editor, abbr, range, options) {\n\tlet cursorMarked = false;\n\tlet newSelectionSize = 0;\n\tlet expanded;\n\n\ttry {\n\t\texpanded = expandAbbreviation(abbr, editor, Object.assign({\n\t\t\t// CodeMirror doesn’t support snippets with tab-stops natively so we have\n\t\t\t// to mark first output with a special token so we can find it later\n\t\t\t// to properly plant cursor into new position\n\t\t\tfield(index, placeholder = '') {\n\t\t\t\tif (!cursorMarked) {\n\t\t\t\t\tcursorMarked = true;\n\t\t\t\t\tnewSelectionSize = placeholder.length;\n\t\t\t\t\tplaceholder = cursorMark + placeholder;\n\t\t\t\t}\n\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}, options));\n\t} catch (err) {\n\t\t// Invalid abbreviation\n\t\t// console.warn(err);\n\t\treturn false;\n\t}\n\n\tconst line = editor.getLine(range.from.line);\n\tconst matchIndent = line.match(/^\\s+/);\n\texpanded = normalizeText(editor, expanded, matchIndent && matchIndent[0]);\n\n\tlet newCursorPos = expanded.length;\n\n\tif (cursorMarked) {\n\t\t// Remove cursor stub and re-position cursor\n\t\tnewCursorPos = expanded.indexOf(cursorMark);\n\t\texpanded = expanded.slice(0, newCursorPos) + expanded.slice(newCursorPos + cursorMark.length);\n\t}\n\n\t// Replace abbreviation with expanded result\n\treturn editor.operation(() => {\n\t\teditor.replaceRange(expanded, range.from, range.to);\n\n\t\t// Position cursor\n\t\tconst startIx = editor.indexFromPos(range.from);\n\t\tconst newCursor = editor.posFromIndex(newCursorPos + startIx);\n\t\tif (newSelectionSize) {\n\t\t\teditor.setSelection(newCursor, {\n\t\t\t\tline: newCursor.line,\n\t\t\t\tch: newCursor.ch + newSelectionSize\n\t\t\t});\n\t\t} else {\n\t\t\teditor.setCursor(newCursor);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Returns options object for syntax from given editor. In most cases, it detects\n * XML-style syntax (HTML, XML, XHTML) and returns options configured for proper\n * output\n * @param  {CodeMirror} editor\n * @param  {Point}      [pos]  Point in editor where syntax should be detected.\n *                             Uses `editor.getCursor()` in not given\n * @return {Object}\n */\nexport function getExpandOptions(editor, pos) {\n\tconst mode = editor.getModeAt(pos || editor.getCursor());\n\tconst emmetOpt = editor.getOption('emmet');\n\tlet profile = emmetOpt && emmetOpt.profile;\n\n\tif (mode.name === 'xml') {\n\t\tprofile = Object.assign({ selfClosingStyle: mode.configuration }, profile);\n\t}\n\n\treturn Object.assign({\n\t\tprofile,\n\t\tsnippets: snippetsFromOptions(editor, detectSyntax(editor, pos))\n\t}, emmetOpt);\n}\n\n/**\n * Returns custom snippets from Emmet options of given editor\n * @param  {CodeMirror} editor\n * @param  {String} syntax\n * @return {Object}\n */\nexport function snippetsFromOptions(editor, syntax) {\n\tconst emmetOpt = editor.getOption('emmet');\n\tif (emmetOpt) {\n\t\treturn isStylesheet(syntax)\n\t\t\t? emmetOpt.stylesheetSnippets\n\t\t\t: emmetOpt.markupSnippets;\n\t}\n}\n","'use strict';\n\nimport { createAbbreviationModel, extractAbbreviation } from './expand-abbreviation';\nimport { hasAutoActivateContext } from './detect-syntax';\n\nconst emmetMarkerClass = 'emmet-abbreviation';\n\n/**\n * Editor’s `change` event handler that marks Emmet abbreviation when editor\n * content is updated\n * @param  {CodeMirror} editor\n */\nexport function markOnEditorChange(editor) {\n\tconst marker = findMarker(editor, editor.getCursor());\n\tif (marker && isValidMarker(editor, marker)) {\n\t\treturn;\n\t}\n\n\t// No valid marker under caret, remove all registered markers\n\t// and create a new one\n\tclearMarkers(editor);\n\tif (hasAutoActivateContext(editor)) {\n\t\tmarkAbbreviation(editor, editor.getCursor());\n\t}\n}\n\n/**\n * Returns *valid* Emmet abbreviation marker (if any) for given position of editor\n * @param  {CodeMirror}     editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {CodeMirror.TextMarker}\n */\nexport function findMarker(editor, pos) {\n\tconst markers = editor.findMarksAt(pos);\n\tfor (let i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\treturn markers[i];\n\t\t}\n\t}\n}\n\n/**\n * Marks Emmet abbreviation for given editor position, if possible\n * @param  {TextEditor} editor   Editor where abbreviation marker should be created\n * @param  {Point}      pos      Buffer position where abbreviation should be created.\n *                               Abbreviation will be automatically extracted from\n *                               given position\n * @param  {Boolean}    [forced] Indicates that user forcibly requested abbreviation\n *                               marker (e.g. was not activated automatically).\n *                               Affects abbreviation detection policy\n * @return {DisplayMarker} Returns `undefined` if no valid abbreviation under caret\n */\nexport function markAbbreviation(editor, pos, forced) {\n\tconst marker = findMarker(editor, pos);\n\tif (marker) {\n\t\t// there’s active marker with valid abbreviation\n\t\treturn marker;\n\t}\n\n\t// No active marker: remove previous markers and create new one, if possible\n\tclearMarkers(editor);\n\n\tconst extracted = extractAbbreviation(editor, pos);\n\tconst model = extracted && createAbbreviationModel(extracted.abbreviation, editor);\n\n\tif (model && (forced || allowedForAutoActivation(model))) {\n\t\tconst from = { line: pos.line, ch: extracted.location };\n\t\tconst to = { line: pos.line, ch: extracted.location + extracted.abbreviation.length };\n\n\t\tconst marker = editor.markText(from, to, {\n\t\t\tinclusiveRight: true,\n\t\t\tclearWhenEmpty: true,\n\t\t\tclassName: emmetMarkerClass\n\t\t});\n\t\tmarker.model = model;\n\t\treturn marker;\n\t}\n}\n\n/**\n * Removes Emmmet abbreviation markers from given editor\n * @param  {TextEditor} editor\n */\nexport function clearMarkers(editor) {\n\tconst markers = editor.getAllMarks();\n\tfor (let i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\tmarkers[i].clear();\n\t\t}\n\t}\n}\n\n/**\n * Check if given abbreviation model is allowed for auto-activated abbreviation\n * marker. Used to reduce falsy activations\n * @param  {Object} model Parsed abbreviation model (see `createAbbreviationModel()`)\n * @return {Boolean}\n */\nfunction allowedForAutoActivation(model) {\n\tconst rootNode = model.ast.children[0];\n\t// The very first node should start with alpha character\n\t// Skips falsy activations for something like `$foo` etc.\n\treturn rootNode && /^[a-z]/i.test(rootNode.name);\n}\n\n/**\n * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation\n * and updates abbreviation model if required\n * @param {CodeMirror} editor\n * @param {CodeMirror.TextMarket} marker\n * @return {Boolean} `true` if marker contains valid abbreviation\n */\nfunction isValidMarker(editor, marker) {\n\tconst range = marker.find();\n\n\t// No newlines inside abreviation\n\tif (range.from.line !== range.to.line) {\n\t\treturn false;\n\t}\n\n\t// Make sure marker contains valid abbreviation\n\tconst text = editor.getRange(range.from, range.to);\n\tif (!text || /^\\s|\\s$/g.test(text)) {\n\t\treturn false;\n\t}\n\n\tif (!marker.model || marker.model.abbreviation !== text) {\n\t\t// marker contents was updated, re-parse abbreviation\n\t\tmarker.model = createAbbreviationModel(text, editor);\n\t}\n\n\treturn !!(marker.model && marker.model.snippet);\n}\n","'use strict';\n\nimport { containsPos, rangeFromNode, narrowToNonSpace } from \"../utils\";\nimport { expandAndInsert } from \"../expand-abbreviation\";\n\n/**\n * Marks selected text or matched node content with abbreviation\n * @param {CodeMirror} editor \n */\nexport default function wrapWithAbbreviation(editor) {\n\tconst range = getWrappingContentRange(editor);\n\n\tif (range) {\n\t\tconst prompt = editor.getOption('emmetPrompt') || defaultPrompt;\n\t\tconst text = editor.getRange(range.from, range.to, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map(line => line.trim());\n\n\t\tprompt(editor, 'Enter abbreviation to wrap with:', abbr => {\n\t\t\tif (abbr) {\n\t\t\t\texpandAndInsert(editor, abbr, range, { text });\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconsole.warn('Nothing to wrap');\n\t}\n}\n\n/**\n * Returns content range that should be wrapped\n * @param {CodeMirror} editor \n */\nfunction getWrappingContentRange(editor) {\n\tif (editor.somethingSelected()) {\n\t\tconst sel = editor.listSelections().filter(sel => sel.anchor !== sel.head)[0];\n\t\tif (sel) {\n\t\t\treturn { from: sel.anchor, to: sel.head };\n\t\t}\n\t}\n\n\t// Nothing selected, find parent HTML node and return range for its content\n\treturn getTagRangeForPos(editor, editor.getCursor());\n}\n\n/**\n * Returns either inner or outer tag range (depending on `pos` location) \n * for given position\n * @param {CodeMirror} editor \n * @param {Object} pos \n * @return {Object}\n */\nfunction getTagRangeForPos(editor, pos) {\n\tconst model = editor.getEmmetDocumentModel();\n\tconst tag = model && model.nodeForPoint(pos);\n\n\tif (!tag) {\n\t\treturn null;\n\t}\n\n\t// Depending on given position, return either outer or inner tag range\n\tif (inRange(tag.open, pos) || inRange(tag.close, pos)) {\n\t\t// Outer range\n\t\treturn rangeFromNode(tag);\n\t}\n\n\t// Inner range\n\tconst from = tag.open.end;\n\tconst to = tag.close ? tag.close.start : tag.open.end;\n\n\treturn narrowToNonSpace(editor, from, to);\n}\n\nfunction inRange(tag, pos) {\n\treturn tag && containsPos(rangeFromNode(tag), pos);\n}\n\nfunction defaultPrompt(editor, message, callback) {\n\tcallback(window.prompt(message));\n}\n","'use strict';\n\nimport { createSnippetsRegistry, isStylesheet } from '@emmetio/expand-abbreviation';\nimport { convertToCSSSnippets } from '@emmetio/css-snippets-resolver';\nimport detectSyntax from './detect-syntax';\nimport expandAbbreviation, { expandAndInsert, snippetsFromOptions } from './expand-abbreviation';\nimport { removeFields } from './utils';\n\n/**\n * Returns available completions from given editor\n * @param  {CodeMirror}      editor\n * @param  {String}          abbrModel   Parsed Emmet abbreviation model for which\n *                                       completions should be populated\n *                                       (see `createAbbreviationModel()`)\n * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor\n * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nexport default function(editor, abbrModel, abbrPos, cursorPos) {\n\tcursorPos = cursorPos || editor.getCursor();\n\tconst syntax = detectSyntax(editor, cursorPos);\n\tif (!syntax) {\n\t\t// Unsupported syntax\n\t\treturn [];\n\t}\n\n\treturn isStylesheet(syntax)\n\t\t? getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos)\n\t\t: getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos);\n}\n\n/**\n * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)\n * @param  {CodeMirror}      editor\n * @param  {Object}          abbrModel   Parsed Emmet abbreviation model for which\n *                                       completions should be populated\n *                                       (see `createAbbreviationModel()`)\n * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor\n * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nexport function getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos) {\n\tlet result = [];\n\tcursorPos = cursorPos || editor.getCursor();\n\n\tconst abbrRange = {\n\t\tfrom: abbrPos,\n\t\tto: { line: abbrPos.line, ch: abbrPos.ch + abbrModel.abbreviation.length }\n\t};\n\n\tresult.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',\n\t\tabbrModel.snippet, () => expandAndInsert(editor, abbrModel.abbreviation, abbrRange)));\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tconst prefix = getMarkupPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);\n\tif (prefix !== null) {\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: cursorPos.line, ch: cursorPos.ch - prefix.length },\n\t\t\tto: cursorPos\n\t\t};\n\n\t\tconst completions = getSnippetCompletions(editor, cursorPos)\n\t\t.filter(snippet => snippet.key !== prefix && snippet.key.indexOf(prefix) === 0)\n\t\t.map(snippet => new EmmetCompletion('snippet', editor, prefixRange, snippet.key,\n\t\t\tsnippet.preview, snippet.key));\n\n\t\tresult = result.concat(completions);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns completions for stylesheet syntaxes\n * @param  {CodeMirror} editor\n * @param  {Object} abbrModel\n * @param  {CodeMirror.Pos} abbrPos\n * @param  {CodeMirror.Pos} cursorPos\n * @return {EmmetCompletion[]}\n */\nfunction getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) {\n\tlet result = [];\n\tcursorPos = cursorPos || editor.getCursor();\n\n\tconst abbrRange = {\n\t\tfrom: abbrPos,\n\t\tto: { line: abbrPos.line, ch: abbrPos.ch + abbrModel.abbreviation.length }\n\t};\n\n\tresult.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',\n\t\tabbrModel.snippet, () => expandAndInsert(editor, abbrModel.abbreviation, abbrRange)));\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tconst prefix = getStylesheetPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);\n\tif (prefix !== null) {\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: cursorPos.line, ch: cursorPos.ch - prefix.length },\n\t\t\tto: cursorPos\n\t\t};\n\n\t\tconst completions = getSnippetCompletions(editor, cursorPos)\n\t\t.filter(snippet => snippet.key !== prefix && snippet.key.indexOf(prefix) === 0)\n\t\t.map(snippet => new EmmetCompletion('snippet', editor, prefixRange,\n\t\t\tsnippet.key, snippet.preview, snippet.key));\n\n\t\tresult = result.concat(completions);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns all possible snippets completions for given editor context.\n * Completions are cached in editor for for re-use\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Array}\n */\nfunction getSnippetCompletions(editor, pos) {\n\tconst syntax = detectSyntax(editor, pos);\n\n\tif (!editor.state.emmetCompletions) {\n\t\teditor.state.emmetCompletions = {};\n\t}\n\n\tconst cache = editor.state.emmetCompletions;\n\n\tif (!(syntax in cache)) {\n\t\tconst registry = createSnippetsRegistry(syntax, snippetsFromOptions(editor, syntax));\n\n\t\tif (isStylesheet(syntax)) {\n\t\t\t// Collect snippets for stylesheet context: just a plain list of\n\t\t\t// snippets, converted specifically for CSS context\n\t\t\tcache[syntax] = convertToCSSSnippets(registry).map(snippet => {\n\t\t\t\tlet preview = snippet.property;\n\t\t\t\tconst keywords = snippet.keywords();\n\t\t\t\tif (keywords.length) {\n\t\t\t\t\tpreview += `: ${removeFields(keywords.join(' | '))}`;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tkey: snippet.key,\n\t\t\t\t\tvalue: snippet.value,\n\t\t\t\t\tkeywords,\n\t\t\t\t\tpreview\n\t\t\t\t};\n\t\t\t});\n\t\t} else {\n\t\t\t// Collect snippets for markup syntaxes: HTML, XML, Slim, Pug etc.\n\t\t\t// Not just a plain snippets list but thier expanded result as well\n\t\t\tconst field = (index, placeholder) => placeholder || '';\n\t\t\tconst expandOpt = { syntax, field };\n\n\t\t\tcache[syntax] = registry.all({type: 'string'}).map(snippet => ({\n\t\t\t\tkey: snippet.key,\n\t\t\t\tvalue: snippet.value,\n\t\t\t\tpreview: expandAbbreviation(snippet.value, editor, expandOpt)\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn cache[syntax];\n}\n\n/**\n * Returns node element prefix, if applicable, for given `pos` in abbreviation\n * for markup syntaxes completions\n * @param  {String} abbr\n * @param  {Number} pos\n * @return {String} Returns `null` if not in element name context\n */\nfunction getMarkupPrefix(abbr, pos) {\n\treturn getPrefix(abbr, pos, /[\\w:\\-\\$@]+$/);\n}\n\n/**\n * Returns node element prefix, if applicable, for given `pos` in abbreviation\n * for stylesheet syntaxes completions\n * @param  {String} abbr\n * @param  {Number} pos\n * @return {String} Returns `null` if not in element name context\n */\nfunction getStylesheetPrefix(abbr, pos) {\n\treturn getPrefix(abbr, pos, /[\\w-@$]+$/);\n}\n\n/**\n * Get snippet completion prefix that matches given `match` regexp from `pos`\n * character pasition of given `abbr` abbreviation\n * @param  {String} abbr\n * @param  {Number} pos\n * @param  {RegExp} match\n * @return {String}\n */\nfunction getPrefix(abbr, pos, match) {\n\tif (pos === 0) {\n\t\t// Word prefix is at the beginning of abbreviation: it’s an element\n\t\t// context for sure\n\t\treturn '';\n\t}\n\n\tconst m = abbr.slice(0, pos).match(match);\n\tconst prefix = m && m[0] || '';\n\n\t// Check if matched prefix is either at the beginning of abbreviation or\n\t// at the element bound, e.g. right after operator\n\tif (prefix && (prefix === abbr || /[>\\^\\+\\(\\)]/.test(abbr[pos - prefix.length - 1]))) {\n\t\treturn prefix;\n\t}\n\n\treturn null;\n}\n\nclass EmmetCompletion {\n\tconstructor(type, editor, range, label, preview, snippet) {\n\t\tthis.type = type;\n\t\tthis.editor = editor;\n\t\tthis.range = range;\n\t\tthis.label = label;\n\t\tthis.preview = preview;\n\t\tthis.snippet = snippet;\n\n\t\tthis._inserted = false;\n\t}\n\n\tinsert() {\n\t\tif (!this._inserted) {\n\t\t\tthis._inserted = true;\n\t\t\tif (typeof this.snippet === 'function') {\n\t\t\t\tthis.snippet(this.editor, this.range);\n\t\t\t} else {\n\t\t\t\tthis.editor.replaceRange(this.snippet, this.range.from, this.range.to);\n\n\t\t\t\t// Position cursor\n\t\t\t\tconst startIx = this.editor.indexFromPos(this.range.from);\n\t\t\t\tconst newCursor = this.editor.posFromIndex(startIx + this.snippet.length);\n\t\t\t\tthis.editor.setCursor(newCursor);\n\t\t\t}\n\t\t}\n\t}\n};\n","import StreamReader from '@emmetio/stream-reader';\nimport { eatPair, eatQuoted, isAlphaNumeric, isQuote, isSpace } from '@emmetio/stream-reader-utils';\n\nclass Node {\n\tconstructor(stream, type, open, close) {\n\t\tthis.stream = stream;\n\t\tthis.type = type;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\n\t\tthis.children = [];\n\t\tthis.parent = null;\n\t}\n\n\t/**\n\t * Returns node name\n\t * @return {String}\n\t */\n\tget name() {\n\t\tif (this.type === 'tag' && this.open) {\n\t\t\treturn this.open && this.open.name && this.open.name.value;\n\t\t}\n\n\t\treturn '#' + this.type;\n\t}\n\n\t/**\n\t * Returns attributes of current node\n\t * @return {Array}\n\t */\n\tget attributes() {\n\t\treturn this.open && this.open.attributes;\n\t}\n\n\t/**\n\t * Returns node’s start position in stream\n\t * @return {*}\n\t */\n\tget start() {\n\t\treturn this.open && this.open.start;\n\t}\n\n\t/**\n\t * Returns node’s start position in stream\n\t * @return {*}\n\t */\n\tget end() {\n\t\treturn this.close ? this.close.end : this.open && this.open.end;\n\t}\n\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\tget nextSibling() {\n\t\tconst ix = this.getIndex();\n\t\treturn ix !== -1 ? this.parent.children[ix + 1] : null;\n\t}\n\n\tget previousSibling() {\n\t\tconst ix = this.getIndex();\n\t\treturn ix !== -1 ? this.parent.children[ix - 1] : null;\n\t}\n\n\t/**\n\t * Returns current element’s index in parent list of child nodes\n\t * @return {Number}\n\t */\n\tgetIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Adds given node as a child\n\t * @param {Node} node\n\t * @return {Node} Current node\n\t */\n\taddChild(node) {\n\t\tthis.removeChild(node);\n\t\tthis.children.push(node);\n\t\tnode.parent = this;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes given node from current node’s child list\n\t * @param  {Node} node\n\t * @return {Node} Current node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * A token factory method\n * @param  {StreamReader}   stream\n * @param  {Point|Function} start  Tokens’ start location or stream consumer\n * @param  {Point}          [end]  Tokens’ end location\n * @return {Token}\n */\nvar token = function(stream, start, end) {\n\treturn typeof start === 'function'\n\t\t? eatToken(stream, start)\n\t\t: new Token(stream, start, end);\n};\n\n/**\n * Consumes characters from given stream that matches `fn` call and returns it\n * as token, if consumed\n * @param  {StreamReader} stream\n * @param  {Function} test\n * @return {Token}\n */\nfunction eatToken(stream, test) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(test)) {\n\t\treturn new Token(stream, start, stream.pos);\n\t}\n\n\tstream.pos = start;\n}\n\n/**\n * A structure describing text fragment in content stream\n */\nclass Token {\n\t/**\n\t * @param {ContentStreamReader} stream\n\t * @param {Point} start         Tokens’ start location in content stream\n\t * @param {Point} end           Tokens’ end location in content stream\n\t */\n\tconstructor(stream, start, end) {\n\t\tthis.stream = stream;\n\t\tthis.start = start != null ? start : stream.start;\n\t\tthis.end   = end   != null ? end   : stream.pos;\n\t\tthis._value = null;\n\t}\n\n\t/**\n\t * Returns token textual value\n\t * NB implemented as getter to reduce unnecessary memory allocations for\n\t * strings that not required\n\t * @return {String}\n\t */\n\tget value() {\n\t\tif (this._value === null) {\n\t\t\tconst start = this.stream.start;\n\t\t\tconst end = this.stream.pos;\n\n\t\t\tthis.stream.start = this.start;\n\t\t\tthis.stream.pos = this.end;\n\t\t\tthis._value = this.stream.current();\n\n\t\t\tthis.stream.start = start;\n\t\t\tthis.stream.pos = end;\n\t\t}\n\n\t\treturn this._value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n\n\tvalueOf() {\n\t\treturn `${this.value} [${this.start}; ${this.end}]`;\n\t}\n}\n\nconst LANGLE  = 60;\nconst RANGLE  = 62;  // < and >\nconst LSQUARE = 91;\nconst RSQUARE = 93;  // [ and ]\nconst LROUND  = 40;\nconst RROUND  = 41;  // ( and )\nconst LCURLY  = 123;\nconst RCURLY  = 125; // { and }\n\nconst opt = { throws: true };\n\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @param  {StreamReader} stream\n * @return {Token} A token with consumed paired character\n */\nvar eatPaired = function(stream) {\n\tconst start = stream.pos;\n\tconst consumed = eatPair(stream, LANGLE, RANGLE, opt)\n\t\t|| eatPair(stream, LSQUARE, RSQUARE, opt)\n\t\t|| eatPair(stream, LROUND,  RROUND,  opt)\n\t\t|| eatPair(stream, LCURLY,  RCURLY,  opt);\n\n\tif (consumed) {\n\t\treturn token(stream, start);\n\t}\n};\n\nconst SLASH$1        = 47;  // /\nconst EQUALS       = 61;  // =\nconst RIGHT_ANGLE$1  = 62;  // >\n\n/**\n * Consumes attributes from given stream\n * @param {StreamReader} stream\n * @return {Array} Array of consumed attributes\n */\nvar eatAttributes = function(stream) {\n\tconst result = [];\n\tlet name, value, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isSpace);\n\t\tattr = { start: stream.pos };\n\n\t\t// A name could be a regular name or expression:\n\t\t// React-style – <div {...props}>\n\t\t// Angular-style – <div [ng-for]>\n\t\tif (attr.name = eatAttributeName(stream)) {\n\t\t\t// Consumed attribute name. Can be an attribute with name\n\t\t\t// or boolean attribute. The value can be React-like expression\n\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\tattr.value = eatAttributeValue(stream);\n\t\t\t} else {\n\t\t\t\tattr.boolean = true;\n\t\t\t}\n\t\t\tattr.end = stream.pos;\n\t\t\tresult.push(attr);\n\t\t} else if (isTerminator(stream.peek())) {\n\t\t\t// look for tag terminator in order to skip any other possible characters\n\t\t\t// (maybe junk)\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Consumes attribute name from current location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeName(stream) {\n\treturn eatPaired(stream) || token(stream, isAttributeName);\n}\n\n/**\n * Consumes attribute value from given location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream)) {\n\t\t// Should return token that points to unquoted value.\n\t\t// Use stream readers’ public API to traverse instead of direct\n\t\t// manipulation\n\t\tconst current = stream.pos;\n\t\tlet valueStart, valueEnd;\n\n\t\tstream.pos = start;\n\t\tstream.next();\n\t\tvalueStart = stream.start = stream.pos;\n\n\t\tstream.pos = current;\n\t\tstream.backUp(1);\n\t\tvalueEnd = stream.pos;\n\n\t\tconst result = token(stream, valueStart, valueEnd);\n\t\tstream.pos = current;\n\t\treturn result;\n\t}\n\n\treturn eatPaired(stream) || eatUnquoted(stream);\n}\n\n/**\n * Check if given code belongs to attribute name.\n * NB some custom HTML variations allow non-default values in name, like `*ngFor`\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAttributeName(code) {\n\treturn code !== EQUALS && !isTerminator(code) && !isSpace(code);\n}\n\n/**\n * Check if given code is tag terminator\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTerminator(code) {\n\treturn code === RIGHT_ANGLE$1 || code === SLASH$1;\n}\n\n/**\n * Eats unquoted value from stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatUnquoted(stream) {\n\treturn token(stream, isUnquoted);\n}\n\n/**\n * Check if given character code is valid unquoted value\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isUnquoted(code) {\n\treturn !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n\nconst DASH        = 45; // -\nconst DOT         = 46; // .\nconst SLASH       = 47; // /\nconst COLON       = 58; // :\nconst LEFT_ANGLE  = 60; // <\nconst RIGHT_ANGLE = 62; // >\nconst UNDERSCORE  = 95; // _\n\n/**\n * Parses tag definition (open or close tag) from given stream state\n * @param {StreamReader} stream Content stream reader\n * @return {Object}\n */\nvar tag = function(stream) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(LEFT_ANGLE)) {\n\t\tconst model = { type: stream.eat(SLASH) ? 'close' : 'open' };\n\n\t\tif (model.name = eatTagName(stream)) {\n\t\t\tif (model.type !== 'close') {\n\t\t\t\tmodel.attributes = eatAttributes(stream);\n\t\t\t\tstream.eatWhile(isSpace);\n\t\t\t\tmodel.selfClosing = stream.eat(SLASH);\n\t\t\t}\n\n\t\t\tif (stream.eat(RIGHT_ANGLE)) {\n\t\t\t\t// tag properly closed\n\t\t\t\treturn Object.assign(token(stream, start), model);\n\t\t\t}\n\t\t}\n\t}\n\n\t// invalid tag, revert to original position\n\tstream.pos = start;\n\treturn null;\n};\n\n/**\n * Eats HTML identifier (tag or attribute name) from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatTagName(stream) {\n\treturn token(stream, isTagName);\n}\n\n/**\n * Check if given character code can be used as HTML/XML tag name\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTagName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === COLON // colon is used for namespaces\n\t\t|| code === DOT   // in rare cases declarative tag names may have dots in names\n\t\t|| code === DASH\n\t\t|| code === UNDERSCORE;\n}\n\n/**\n * Eats array of character codes from given stream\n * @param  {StreamReader} stream\n * @param  {Number[]} codes  Array of character codes\n * @return {Boolean}\n */\nfunction eatArray(stream, codes) {\n\tconst start = stream.pos;\n\n\tfor (let i = 0; i < codes.length; i++) {\n\t\tif (!stream.eat(codes[i])) {\n\t\t\tstream.pos = start;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstream.start = start;\n\treturn true;\n}\n\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @param  {StreamReader} stream\n * @param  {Number[]} open\n * @param  {Number[]} close\n * @return {Boolean}  Returns `true` if section was consumed\n */\nfunction eatSection(stream, open, close, allowUnclosed) {\n\tconst start = stream.pos;\n\tif (eatArray(stream, open)) {\n\t\t// consumed `<!--`, read next until we find ending part or reach the end of input\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatArray(stream, close)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream.next();\n\t\t}\n\n\t\t// unclosed section is allowed\n\t\tif (allowUnclosed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tstream.pos = start;\n\t\treturn false;\n\t}\n\n\t// unable to find section, revert to initial position\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Converts given string into array of character codes\n * @param  {String} str\n * @return {Number[]}\n */\nfunction toCharCodes(str) {\n\treturn str.split('').map(ch => ch.charCodeAt(0));\n}\n\nconst open  = toCharCodes('<!--');\nconst close = toCharCodes('-->');\n\n/**\n * Consumes HTML comment from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar comment = function(stream) {\n\tconst start = stream.pos;\n\tif (eatSection(stream, open, close, true)) {\n\t\tconst result = token(stream, start);\n\t\tresult.type = 'comment';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nconst open$1  = toCharCodes('<![CDATA[');\nconst close$1 = toCharCodes(']]>');\n\n/**\n * Consumes CDATA from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar cdata = function(stream) {\n\tconst start = stream.pos;\n\tif (eatSection(stream, open$1, close$1, true)) {\n\t\tconst result = token(stream, start);\n\t\tresult.type = 'cdata';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nconst defaultOptions = {\n\t/**\n\t * Expect XML content in searching content. It alters how should-be-empty\n\t * elements are treated: for example, in XML mode parser will try to locate\n\t * closing pair for `<br>` tag\n\t * @type {Boolean}\n\t */\n\txml: false,\n\n\tspecial: ['script', 'style'],\n\n\t/**\n\t * List of elements that should be treated as empty (e.g. without closing tag)\n\t * in non-XML syntax\n\t * @type {Array}\n\t */\n\tempty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr','col', 'embed', 'input', 'param', 'source', 'track']\n};\n\n/**\n * Parses given content into a DOM-like structure\n * @param  {String|StreamReader} content\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse(content, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst stream = typeof content === 'string'\n\t\t? new StreamReader(content)\n\t\t: content;\n\n\tconst root = new Node(stream, 'root');\n\tconst empty = new Set(options.empty);\n\tconst special = options.special.reduce(\n\t\t(map, name) => map.set(name, toCharCodes(`</${name}>`)), new Map());\n\tconst isEmpty = (token, name) =>\n\t\ttoken.selfClosing || (!options.xml && empty.has(name));\n\n\tlet m, node, name, stack = [root];\n\n\twhile (!stream.eof()) {\n\t\tif (m = match(stream)) {\n\t\t\tname = getName(m);\n\n\t\t\tif (m.type === 'open') {\n\t\t\t\t// opening tag\n\t\t\t\tnode = new Node(stream, 'tag', m);\n\t\t\t\tlast(stack).addChild(node);\n\t\t\t\tif (special.has(name)) {\n\t\t\t\t\tnode.close = consumeSpecial(stream, special.get(name));\n\t\t\t\t} else if (!isEmpty(m, name)) {\n\t\t\t\t\tstack.push(node);\n\t\t\t\t}\n\t\t\t} else if (m.type === 'close') {\n\t\t\t\t// closing tag, find it’s matching opening tag\n\t\t\t\tfor (let i = stack.length - 1; i > 0; i--) {\n\t\t\t\t\tif (stack[i].name.toLowerCase() === name) {\n\t\t\t\t\t\tstack[i].close = m;\n\t\t\t\t\t\tstack = stack.slice(0, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlast(stack).addChild(new Node(stream, m.type, m));\n\t\t\t}\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn root;\n}\n\n/**\n * Matches known token in current state of given stream\n * @param  {ContentStreamReader} stream\n * @return {Token}\n */\nfunction match(stream) {\n\t// fast-path optimization: check for `<` code\n\tif (stream.peek() === 60 /* < */) {\n\t\treturn comment(stream) || cdata(stream) || tag(stream);\n\t}\n}\n\n/**\n * @param  {StreamReader} stream\n * @param  {Number[]} codes\n * @return {Token}\n */\nfunction consumeSpecial(stream, codes) {\n\tconst start = stream.pos;\n\tlet m;\n\n\twhile (!stream.eof()) {\n\t\tif (eatArray(stream, codes)) {\n\t\t\tstream.pos = stream.start;\n\t\t\treturn tag(stream);\n\t\t}\n\t\tstream.next();\n\t}\n\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Returns name of given matched token\n * @param  {Token} tag\n * @return {String}\n */\nfunction getName(tag$$1) {\n\treturn tag$$1.name ? tag$$1.name.value.toLowerCase() : `#${tag$$1.type}`;\n}\n\nfunction last(arr) {\n\treturn arr[arr.length - 1];\n}\n\nexport { defaultOptions, match };export default parse;\n","'use strict';\n\nimport { containsPos, rangeFromNode } from '../utils';\n\n/**\n * A syntax-specific model container, used to get unified access to underlying\n * parsed document\n */\nexport default class SyntaxModel {\n\t/**\n\t * @param  {Object} dom      Parsed document tree\n\t * @param  {String} type     Type of document (html, stylesheet, etc.)\n\t * @param  {String} [syntax] Optional document syntax like html, xhtml or xml\n\t */\n\tconstructor(dom, type, syntax) {\n\t\tthis.dom = dom;\n\t\tthis.type = type;\n\t\tthis.syntax = syntax;\n\t}\n\n\t/**\n\t * Returns best matching node for given point\n\t * @param  {CodeMirror.Pos}   pos\n\t * @param  {Boolean} [exclude] Exclude node’s start and end positions from\n\t *                             search\n\t * @return {Node}\n\t */\n\tnodeForPoint(pos, exclude) {\n\t\tlet ctx = this.dom.firstChild;\n\t\tlet found = null;\n\n\t\twhile (ctx) {\n\t\t\tif (containsPos(rangeFromNode(ctx), pos, exclude)) {\n\t\t\t\t// Found matching tag. Try to find deeper, more accurate match\n\t\t\t\tfound = ctx;\n\t\t\t\tctx = ctx.firstChild;\n\t\t\t} else {\n\t\t\t\tctx = ctx.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn found;\n\t}\n}\n","'use strict';\n\nimport parseHTML from '@emmetio/html-matcher';\nimport SyntaxModel from './syntax-model';\nimport StreamReader from '../stream-reader';\n\n/**\n * Creates DOM-like model for given text editor\n * @param  {CodeMirror} editor\n * @param  {String}     syntax\n * @return {Node}\n */\nexport default function create(editor, syntax) {\n\tconst stream = new StreamReader(editor);\n\tconst xml = syntax === 'xml';\n\n\ttry {\n\t\treturn new SyntaxModel(parseHTML(stream, { xml }), 'html', syntax || 'html');\n\t} catch (err) {\n\t\tconsole.warn(err);\n\t}\n}\n","'use strict';\n\nimport parseHTML from './html';\n\nexport default function getModel(editor) {\n\tconst syntax = getSyntax(editor);\n\treturn parseHTML(editor, syntax);\n}\n\nexport function getCachedModel(editor) {\n\tif (!editor.state._emmetModel) {\n\t\teditor.state._emmetModel = getModel(editor);\n\t}\n\n\treturn editor.state._emmetModel;\n}\n\nexport function resetCachedModel(editor) {\n\teditor.state._emmetModel = null;\n}\n\n/**\n * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).\n * Returns `null` if editor’s syntax is unsupported\n * @param  {CodeMirror} editor\n * @return {String}\n */\nfunction getSyntax(editor) {\n\tconst mode = editor.getMode();\n\n\tif (mode.name === 'htmlmixed') {\n\t\treturn 'html';\n\t}\n\n\treturn mode.name === 'xml' ? mode.configuration : mode.name;\n}\n","'use strict';\n\nimport { containsPos } from './utils';\n\nconst openTagMark = 'emmet-open-tag';\nconst closeTagMark = 'emmet-close-tag';\n\n/**\n * Finds matching tag pair for given position in editor\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Object}\n */\nexport default function matchTag(editor, pos) {\n\tpos = pos || editor.getCursor();\n\n\t// First, check if there are tag markers in editor\n\tconst marked = getMarkedTag(editor);\n\n\t// If marks found, validate them: make sure cursor is either in open\n\t// or close tag\n\tif (marked) {\n\t\tif (containsPos(marked.open.find(), pos)) {\n\t\t\t// Point is inside open tag, make sure if there’s a closing tag,\n\t\t\t// it matches open tag content\n\t\t\tif (!marked.close || text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t} else if (marked.close) {\n\t\t\t// There’s a close tag, make sure pointer is inside it and it matches\n\t\t\t// open tag\n\t\t\tif (containsPos(marked.close.find(), pos) && text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Markers are not valid anymore, remove them\n\tclearTagMatch(editor);\n\n\t// Find new tag pair from parsed HTML model and mark them\n\tconst node = findTagPair(editor, pos);\n\tif (node && node.type === 'tag') {\n\t\treturn {\n\t\t\topen: createTagMark(editor, node.open.name, openTagMark),\n\t\t\tclose: node.close && createTagMark(editor, node.close.name, closeTagMark)\n\t\t};\n\t}\n}\n\nexport function getMarkedTag(editor) {\n\tlet open, close;\n\teditor.getAllMarks().forEach(mark => {\n\t\tif (mark.className === openTagMark) {\n\t\t\topen = mark;\n\t\t} else if (mark.className === closeTagMark) {\n\t\t\tclose = mark;\n\t\t}\n\t});\n\n\treturn open ? { open, close } : null;\n}\n\n/**\n * Removes all matched tag pair markers from editor\n * @param  {CodeMirror} editor\n */\nexport function clearTagMatch(editor) {\n\teditor.getAllMarks().forEach(mark => {\n\t\tif (mark.className === openTagMark || mark.className === closeTagMark) {\n\t\t\tmark.clear();\n\t\t}\n\t});\n}\n\n/**\n * Finds tag pair (open and close, if any) form parsed HTML model of given editor\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Object}\n */\nexport function findTagPair(editor, pos) {\n\tconst model = editor.getEmmetDocumentModel();\n\treturn model && model.nodeForPoint(pos || editor.getCursor());\n}\n\nfunction createTagMark(editor, tag, className) {\n\treturn editor.markText(tag.start, tag.end, {\n\t\tclassName,\n\t\tinclusiveLeft: true,\n\t\tinclusiveRight: true,\n\t\tclearWhenEmpty: false\n\t});\n}\n\nfunction text(editor, mark) {\n\tconst range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n","'use strict';\n\nimport { getMarkedTag, clearTagMatch } from './match-tag';\nimport { containsPos } from './utils';\n\nexport default function renameTag(editor, obj) {\n\tconst tag = getMarkedTag(editor);\n\tconst pos = obj.from;\n\n\tif (!tag) {\n\t\treturn;\n\t}\n\n\tif (containsPos(tag.open.find(), pos) && tag.close) {\n\t\t// Update happened inside open tag, update close tag as well\n\t\tupdateTag(editor, tag.open, tag.close);\n\t} else if (tag.close && containsPos(tag.close.find(), pos)) {\n\t\t// Update happened inside close tag, update open tag as well\n\t\tupdateTag(editor, tag.close, tag.open);\n\t}\n}\n\nexport function updateTag(editor, source, dest) {\n\tconst name = text(editor, source);\n\tconst range = dest.find();\n\tconst m = name.match(/[\\w:\\-]+/);\n\tconst newName = !name ? '' : (m && m[0]);\n\n\tif (newName != null) {\n\t\tif (editor.getRange(range.from, range.to) !== newName) {\n\t\t\teditor.replaceRange(newName, range.from, range.to);\n\t\t}\n\t} else {\n\t\t// User entered something that wasn’t a valid tag name.\n\t\tclearTagMatch(editor);\n\t}\n}\n\nfunction text(editor, mark) {\n\tconst range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n","'use strict';\n\nimport emmetExpandAbbreviation from './lib/commands/expand-abbreviation';\nimport emmetInsertLineBreak from './lib/commands/formatted-line-break';\nimport emmetWrapWithAbbreviation from './lib/commands/wrap-with-abbreviation';\nimport {\n\tmarkOnEditorChange, findMarker, markAbbreviation, clearMarkers\n} from './lib/abbreviation-marker';\nimport autocompleteProvider from './lib/autocomplete';\nimport { extractAbbreviation, parseAbbreviation, createAbbreviationModel } from './lib/expand-abbreviation';\nimport getModel, { getCachedModel, resetCachedModel } from './lib/model/index';\nimport matchTag, { clearTagMatch } from './lib/match-tag';\nimport renameTag from './lib/rename-tag';\n\nconst commands = { emmetExpandAbbreviation, emmetInsertLineBreak, emmetWrapWithAbbreviation };\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nexport default function registerEmmetExtension(CodeMirror) {\n\t// Register Emmet commands\n\tObject.assign(CodeMirror.commands, commands);\n\n\t// Defines options that allows abbreviation marking in text editor\n\tCodeMirror.defineOption('markEmmetAbbreviation', true, (editor, value) => {\n\t\tif (value) {\n\t\t\teditor.on('change', markOnEditorChange);\n\t\t} else {\n\t\t\teditor.off('change', markOnEditorChange);\n\t\t\tclearMarkers(editor);\n\t\t}\n\t});\n\n\tCodeMirror.defineOption('autoRenameTags', true, (editor, value) => {\n\t\tvalue ? editor.on('change', renameTag) : editor.off('change', renameTag);\n\t});\n\n\tCodeMirror.defineOption('markTagPairs', false, (editor, value) => {\n\t\tif (value) {\n\t\t\teditor.on('cursorActivity', matchTag);\n\t\t\teditor.on('change', resetCachedModel);\n\t\t} else {\n\t\t\teditor.off('cursorActivity', matchTag);\n\t\t\teditor.off('change', resetCachedModel);\n\t\t\tresetCachedModel(editor);\n\t\t\tclearTagMatch(editor);\n\t\t}\n\t});\n\n\t// Additional options for Emmet, for Expand Abbreviation action mostly:\n\t// https://github.com/emmetio/expand-abbreviation/blob/master/index.js#L26\n\tCodeMirror.defineOption('emmet', {});\n\n\t/**\n\t * Returns Emmet completions for context from `pos` position.\n\t * Abbreviations are calculated for marked abbreviation at given position.\n\t * If no parsed abbreviation marker is available and `force` argument is\n\t * given, tries to mark abbreviation and populate completions list again.\n\t * @param  {CodeMirror.Pos} [pos]\n\t * @param  {Boolean}        [force]\n\t * @return {EmmetCompletion[]}\n\t */\n\tCodeMirror.defineExtension('getEmmetCompletions', function(pos, force) {\n\t\tconst editor = this;\n\t\tif (typeof pos === 'boolean') {\n\t\t\tforce = pos;\n\t\t\tpos = null;\n\t\t}\n\n\t\tlet abbrRange, list;\n\n\t\tpos = pos || editor.getCursor();\n\t\tif (editor.getOption('markEmmetAbbreviation')) {\n\t\t\t// Get completions from auto-inserted marker\n\t\t\tconst marker = findMarker(editor, pos) || (force && markAbbreviation(editor, pos, true));\n\t\t\tif (marker) {\n\t\t\t\tabbrRange = marker.find();\n\t\t\t\tlist = autocompleteProvider(editor, marker.model, abbrRange.from, pos);\n\t\t\t}\n\t\t} else {\n\t\t\t// No abbreviation auto-marker, try to extract abbreviation from given\n\t\t\t// cursor location\n\t\t\tconst extracted = extractAbbreviation(editor, pos);\n\t\t\tif (extracted) {\n\t\t\t\tconst model = createAbbreviationModel(extracted.abbreviation, editor);\n\t\t\t\tif (model) {\n\t\t\t\t\tabbrRange = {\n\t\t\t\t\t\tfrom: { line: pos.line, ch: extracted.location },\n\t\t\t\t\t\tto: { line: pos.line, ch: extracted.location + extracted.abbreviation.length }\n\t\t\t\t\t};\n\t\t\t\t\tlist = autocompleteProvider(editor, model, abbrRange.from, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (list && list.length) {\n\t\t\treturn {\n\t\t\t\tfrom: abbrRange.from,\n\t\t\t\tto: abbrRange.to,\n\t\t\t\tlist\n\t\t\t};\n\t\t}\n\t});\n\n\t/**\n\t * Returns valid Emmet abbreviation and its location in editor from given\n\t * position\n\t * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be\n\t *                                extracted. If not given, current cursor\n\t *                                position is used\n\t * @return {Object} Object with `abbreviation` and `location` properties\n\t * or `null` if there’s no valid abbreviation\n\t */\n\tCodeMirror.defineExtension('getEmmetAbbreviation', function(pos) {\n\t\tconst editor = this;\n\t\tpos = pos || editor.getCursor();\n\t\tconst marker = findMarker(editor, pos);\n\n\t\tif (marker) {\n\t\t\treturn {\n\t\t\t\tabbreviation: marker.model.abbreviation,\n\t\t\t\tast: marker.model.ast,\n\t\t\t\tlocation: marker.find().from,\n\t\t\t\tfromMarker: true\n\t\t\t};\n\t\t}\n\n\t\tconst extracted = extractAbbreviation(editor, pos);\n\t\tif (extracted) {\n\t\t\ttry {\n\t\t\t\treturn {\n\t\t\t\t\tabbreviation: extracted.abbreviation,\n\t\t\t\t\tast: parseAbbreviation(extracted.abbreviation, editor),\n\t\t\t\t\tlocation: { line: pos.line,  ch: extracted.location },\n\t\t\t\t\tfromMarker: false\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\t// Will throw if abbreviation is invalid\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t});\n\n\tCodeMirror.defineExtension('findEmmetMarker', function(pos) {\n\t\treturn findMarker(this, pos || this.getCursor());\n\t});\n\n\tCodeMirror.defineExtension('getEmmetDocumentModel', function() {\n\t\tconst editor = this;\n\t\treturn editor.getOption('markTagPairs')\n\t\t\t? getCachedModel(editor)\n\t\t\t: getModel(editor);\n\t});\n}\n","'use strict';\n\nimport { findMarker, clearMarkers } from '../abbreviation-marker';\nimport { extractAbbreviation, expandAndInsert } from '../expand-abbreviation';\n\n/**\n * Expand abbreviation command\n * @param  {CodeMirror} editor\n */\nexport default function(editor) {\n\tif (editor.somethingSelected()) {\n\t\treturn editor.constructor.Pass;\n\t}\n\n\tconst pos = editor.getCursor();\n\tconst marker = findMarker(editor, pos);\n\n\tlet result = false;\n\n\t// Handle two possible options: expand abbreviation from Emmet marker that\n\t// matches given location or extract & expand abbreviation from cursor\n\t// position. The last one may happen if either `markEmmetAbbreviation`\n\t// option is turned off or user moved cursor away from Emmet marker and\n\t// tries to expand another abbreviation\n\n\tif (marker) {\n\t\tresult = expandAndInsert(editor, marker.model.ast, marker.find());\n\t} else {\n\t\tconst abbrData = extractAbbreviation(editor, pos);\n\t\tif (abbrData) {\n\t\t\tconst range = {\n\t\t\t\tfrom: {\n\t\t\t\t\tline: pos.line,\n\t\t\t\t\tch: abbrData.location\n\t\t\t\t},\n\t\t\t\tto: {\n\t\t\t\t\tline: pos.line,\n\t\t\t\t\tch: abbrData.location + abbrData.abbreviation.length\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tresult = expandAndInsert(editor, abbrData.abbreviation, range);\n\t\t}\n\t}\n\n\tclearMarkers(editor);\n\n\t// If no abbreviation was expanded, allow editor to handle different\n\t// action for keyboard shortcut (Tab key mostly)\n\treturn result || editor.constructor.Pass;\n}\n","'use strict';\n\nexport default function(editor) {\n\tconst between = editor.listSelections().map(sel => betweenTags(editor, sel));\n\n\tif (!between.some(Boolean)) {\n\t\treturn editor.constructor.Pass;\n\t}\n\n\teditor.operation(() => {\n\t\tlet sels = editor.listSelections();\n\t\tconst singleSep = editor.doc.lineSeparator();\n\t\tconst doubleSep = singleSep + singleSep;\n\n\t\t// Step 1: insert newlines either single or double depending on selection\n\t\tfor (let i = sels.length - 1; i >= 0; i--) {\n\t\t\teditor.replaceRange(between[i] ? doubleSep : singleSep, sels[i].anchor, sels[i].head, '+newline');\n\t\t}\n\n\t\t// Step 2: indent inserted lines\n\t\tsels = editor.listSelections();\n\t\tfor (let i = 0; i < sels.length; i++) {\n\t\t\teditor.indentLine(sels[i].from().line, null, true);\n\n\t\t\tif (between[i]) {\n\t\t\t\teditor.indentLine(sels[i].from().line - 1, null, true);\n\t\t\t}\n\t\t}\n\n\t\t// Step 3: adjust caret positions\n\t\teditor.setSelections(editor.listSelections().map((sel, i) => {\n\t\t\tif (between[i]) {\n\t\t\t\tconst line = sel.from().line - 1;\n\t\t\t\tconst cursor = {\n\t\t\t\t\tline,\n\t\t\t\t\tch: editor.getLine(line).length\n\t\t\t\t};\n\t\t\t\treturn { anchor: cursor, head: cursor };\n\t\t\t}\n\n\t\t\treturn sel;\n\t\t}));\n\t});\n}\n\n/**\n * Check if given range is a single caret between tags\n * @param {CodeMirror} editor\n * @param {CodeMirror.range} range\n */\nfunction betweenTags(editor, range) {\n\tif (equalCursorPos(range.anchor, range.head)) {\n\t\tconst cursor = range.anchor;\n\t\tconst mode = editor.getModeAt(cursor);\n\n\t\tif (mode.name === 'xml') {\n\t\t\tconst left = editor.getTokenAt(cursor);\n\t\t\tconst right = editor.getTokenAt(Object.assign({}, cursor, { ch: cursor.ch + 1 }));\n\n\t\t\treturn left.type === 'tag bracket' && left.string === '>'\n\t\t\t\t&& right.type === 'tag bracket' && right.string === '</';\n\t\t}\n\t}\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n\nfunction equalCursorPos(a, b) {\n\treturn a.sticky === b.sticky && cmp(a, b) === 0;\n}\n\n","'use strict';\n\nimport registerEmmetExtension from './extension.js';\n\nif (typeof CodeMirror !== 'undefined') {\n\tregisterEmmetExtension(CodeMirror);\n}\n"],"names":["StreamReader","string","this","pos","length","sol","peek","offset","charCodeAt","prev","eat","match","ok","eatWhile","start","const","SINGLE_QUOTE","DOUBLE_QUOTE","ESCAPE","isQuote","c","TAB","SPACE","DASH","COLON","EQUALS","isAtHTMLTag","stream","let","isWhiteSpace","eatIdent","eatAttributeWithUnquotedValue","eatAttribute","quote","eatQuoted","eatAttributeWithQuotedValue","isUnquotedValue","isIdent","isAlpha","isNumber","code","ch","SQUARE_BRACE_L","SQUARE_BRACE_R","ROUND_BRACE_L","ROUND_BRACE_R","CURLY_BRACE_L","CURLY_BRACE_R","specialChars","Set","split","map","bracePairs","Map","set","extractAbbreviation","line","lookAhead","Math","min","max","isCloseBrace","offsetPastAutoClosed","stack","push","isOpenBrace","pop","get","has","isAbbreviation","abbreviation","slice","replace","location","arr","value","indexOf","defaultOptions","indent","tagCase","attributeCase","attributeQuotes","format","formatSkip","formatForce","inlineBreak","compactBooleanAttributes","booleanAttributes","selfClosingStyle","inlineElements","Profile","options","Object","assign","quoteChar","strcase","type","toUpperCase","toLowerCase","name","str","attribute","attr","isBooleanAttribute","boolean","selfClose","level","output","isInline","node","isTextOnly","field","index","placeholder","Snippet","key","SnippetsStorage","data","_string","_regexp","_disabled","load","prototypeAccessors","disabled","disable","enable","forEach","k","RegExp","Error","keys","Array","from","i","il","test","reset","clear","values","regexp","concat","SnippetsRegistry","_registry","isArray","snippets","add","item","store","remove","sort","a","b","filter","resolve","snippet","all","result","fillResult","Attribute","clone","valueOf","Node","attributes","repeat","selfClosing","children","parent","next","previous","_attributes","setAttribute","createAttribute","normalize","String","trim","uniqueClass","attributesMap","reduce","out","isGroup","firstChild","lastChild","childIndex","nextSibling","previousSibling","classList","getAttribute","create","curAttr","replaceAttribute","hasAttribute","curAttribute","newName","newValue","ix","splice","removeAttribute","clearAttributes","addClass","token","hasClass","join","removeClass","appendChild","insertAt","insertBefore","newNode","refNode","removeChild","deep","child","walk","fn","_level","ctx","use","args","arguments","apply","toString","attrs","opt","implied","count","end","eof","limit","constructor","backUp","n","current","substring","error","message","err","originalMessage","escape","throws","to","isAlphaNumeric","isSpace","defaultOptions$1","eatPair","open","close","fromCharCode","consumeRepeat","consumeQuoted","TEXT_START","TEXT_END","consumeText","EXCL","DOT$1","ATTR_OPEN","ATTR_CLOSE","reAttributeName","consumeAttributes","eatUnquoted","parseAttributeName","before","after","isUnquoted","consumeElement","eatName","isName","GROUP_START","GROUP_END","OP_SIBLING","OP_CHILD","OP_CLIMB","abbr","tree","root","groupStack","lastGroup","parse","unroll","registry","delete","childTarget","findDeepestNode","classNames","mergeClassNames","attrMap","newAttrs","mergeAttributes","merge","resolveNode","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","resolveImplicitName","parentName","implicitTags","resolveImplicitTag","findUnescapedTokens","tlen","size","len","replaceRanges","ranges","r","offsetLength","descendingOrder","substr","matches","Number","parseInt","numberingToken","applyNumbering","applyNumbering$1","repeater","findRepeater","replaceNumbering","copy","unescapeString","_value","replaceNumberingRanges","range$$1","lastRange","getNumberingRanges","caret","reUrl","reEmail","reProto","prepare","amount","implicit","insert","content","updated","inserted","insertContentIntoPlaceholder","setNodeContent","insertContent","state","replaced","replacePlaceholder","_state","element","modifier","reElement","reModifier","blockCandidates1","className","blockCandidates2","getBlockName","lookup","prefix","depth","find","oldName","reSupporterNames","supportedAddons","cl","startsWith","expandClassNames","createBlockLookup","m","originalClass","arrClassNames","Boolean","expandShortNotation","addons","addonOpt","appliedAddons","replaceVariables","variables","replaceInString","replaceInNode","model","reVariable","tokens","exec","validMatches","createModel","v","DOLLAR","OPEN_BRACE","CLOSE_BRACE","fields","cleanString","consumeField","FieldString","createToken","consumeIndex","Field","consumePlaceholder","mark","order","defaultFieldsRenderer","text","OutputNode","fieldsRenderer","_fieldsRenderer","beforeOpen","afterOpen","beforeClose","afterClose","beforeText","afterText","newline","indentText","lines","splitByLines","nl","renderFields","_wrap","defaultField","render","formatter","fieldState","run","nodes","outNode","parseFields","largestIndex","getFieldsModel","TOKEN","TOKEN_OPEN","TOKEN_CLOSE","template","lastPos","replacer","left","right","isFirstChild","isRoot","isPseudoSnippet","handlePseudoSnippet","fieldsModel","parts","splitFieldsModel","commentOptions","enabled","trigger","shouldFormatNode","profile","adjacentInline","isInlineElement","shouldFormatInline","reId","reClass","defaultAttrOptions","primary","secondary","isBoolean","defaultNodeOptions","omitName","indentFormat","getIndentLevel$1","NAME","SELF_CLOSE","PRIMARY_ATTRS","SECONDARY_ATTRS","getAttributes","reNl","reNl$1","secondaryAttrs","none","round","curly","square","reNl$2","supportedSyntaxed","comment","skip","getIndentLevel","nodeName","hasInnerFormatting","setFormatting","attrName","attrValue","formatAttributes","commentNode","nodeOptions","updateFormatting","maxLength","formatNodeValue","attributeWrap","booleanAttr","isInline$1","updateFormatting$1","formatNodeValue$1","updateFormatting$2","formatNodeValue$2","syntax","supports","CSSValue","consumeColor","isHex","base","Color","alpha","raw","g","isShortHex","hex","toShortHex","num","toHex","pad","isAlphaNumericWord","isAlphaWord","short","toRGB","toFixed","DASH$1","consumeNumericValue","negative","hadDot","consumed","eatNumber","NumericValue","unit","DASH$2","consumeKeyword","isVariableName","isKeyword","Keyword","QuotedString","LBRACE","RBRACE","COMMA","consumeArgumentList","arg","argsList","consumeArgument","consumeKeywordOrFunction","kw","FunctionCall","AT","consumeIdent","consumeValue","isIdentPrefix","stringScore","ch1","ch2","found","acronym","abbrLength","stringLength","j","score","reProperty","cssSnippets","snippetsSort","cur","property","addDependency","nest","CSSSnippet","dependencies","isKeyword$1","splitValue","dep","defaulValue","keywords","candidates","deps","globalKeywords","unitlessProperties","e","x","convertToCSSSnippets","intUnit","floatUnit","unitAliases","fuzzySearchMinScore","findBestMatch","setNodeAsText","formatOptions","isNumericValue","resolveNumericValue","getUnmatchedPart","resolveAsProperty","resolveAsSnippet","items","matchedItem","maxScore","getScoringPart","tokenTypeOf","shortHex","between","css","fieldsAmount","shift","delta","injectFields","stringifyAttribute","endsWith","syntaxFormat","scss","less","sass","stylus","stylesheet","getFormat","a:link","a:mail","a:tel","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","style","script","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","label","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","cc:ie","cc:noie","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","ap","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cp","cps","d","ec","f","fef","fem","femp","fems","ff","fl","fs","fsm","fv","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fz","fza","h","jc","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","op","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","q","qen","qru","rsz","t","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","tm|tmatch","tn|tname","call","api","imp","inc","wh|xsl:when","ot","if","par","pare","var","vare","wp","elem","co","val","for|each","tex","com","msg","fall","nam","pres","strip","proc","choose","xsl","langs","common","words","wordCount","skipCommon","lang","dict","latin","startWithCommon","isRepeating","paragraph","rand","floor","random","sample","iterations","sentence","word","insertCommas","hasComma","totalCommas","totalWords","parse$1","parseAbbreviation","resolveSnippets","resolveVariables","transform","parse$2","parseAbbreviation$1","resolveSnippets$1","reLorem","snippetsRegistryFactory","registrySnippets","defaultSnippets","html","loremGenerator","lorem","defaultVariables","locale","charset","stylesheetSyntaxes","expand$$1","isStylesheet","createOptions","format$1","expand$2","expand$1","createSnippetsRegistry","createProfile","knownSyntaxes","stylesheetAutoActivationContext","editor","tokenType","getTokenTypeAt","getCursor","autoActivationContext","detectSyntax","mode","getModeAt","isSupported","emmetOpt","getOption","CodeMirrorStreamReader","super","CodeMirror","Pos","lastLine","_eof","_lineLength","_sof","sof","comparePos","lineStr","getLine","NaN","getRange","isLast","normalizeText","indentation","repeatString","getIndentation","tabs","containsPos","range","exclude","rangeFromNode","cursorMark","editorField","expandAbbreviation","expand","getExpandOptions","extract","createAbbreviationModel","expandAndInsert","expanded","cursorMarked","newSelectionSize","matchIndent","newCursorPos","operation","replaceRange","startIx","indexFromPos","newCursor","posFromIndex","setSelection","setCursor","configuration","snippetsFromOptions","stylesheetSnippets","markupSnippets","emmetMarkerClass","markOnEditorChange","marker","findMarker","isValidMarker","clearMarkers","hasAutoActivateContext","markAbbreviation","markers","findMarksAt","forced","extracted","rootNode","ast","allowedForAutoActivation","markText","inclusiveRight","clearWhenEmpty","getAllMarks","inRange","tag","defaultPrompt","callback","window","prompt","abbrModel","abbrPos","cursorPos","abbrRange","EmmetCompletion","getPrefix","prefixRange","completions","getSnippetCompletions","preview","getStylesheetCompletions","getMarkupCompletions","emmetCompletions","cache","expandOpt","_inserted","getIndex","addChild","Token","eatToken","prototypeAccessors$1","eatPaired","SLASH$1","RIGHT_ANGLE$1","eatAttributeName","isAttributeName","eatAttributeValue","valueStart","valueEnd","isTerminator","isNaN","DOT","UNDERSCORE","isTagName","eatTagName","eatAttributes","eatArray","codes","eatSection","allowUnclosed","toCharCodes","open$1","close$1","cdata","xml","special","empty","consumeSpecial","last","SyntaxModel","dom","tag$$1","isEmpty","parseHTML","console","warn","getModel","getMode","getSyntax","resetCachedModel","_emmetModel","nodeForPoint","openTagMark","closeTagMark","matchTag","marked","getMarkedTag","clearTagMatch","getEmmetDocumentModel","findTagPair","createTagMark","inclusiveLeft","renameTag","updateTag","source","dest","commands","somethingSelected","Pass","abbrData","listSelections","sel","anchor","head","sticky","cmp","cursor","getTokenAt","betweenTags","some","sels","singleSep","lineSeparator","doubleSep","indentLine","setSelections","narrowToNonSpace","getTagRangeForPos","getWrappingContentRange","defineOption","on","off","defineExtension","force","autocompleteProvider","fromMarker","getCachedModel","registerEmmetExtension"],"mappings":"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"}